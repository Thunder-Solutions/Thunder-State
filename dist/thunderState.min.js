'use strict';const deepClone = (value) => {
    // primitives are inherently cloned
    const isPrimitive = value === null || typeof value !== 'object' && typeof value !== 'function';
    if (isPrimitive)
        return value;
    // clone objects
    if (typeof structuredClone !== 'undefined')
        return structuredClone(value);
    /**
     * This is a (non-optimized) fallback in case of old versions of Node.
     * According to MDN, structuredClone is now supported in all modern browsers.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/structuredClone
     */
    return JSON.parse(JSON.stringify(value));
};
/**
 * Get equivalence of any two values; objects will compare deep structure and every property's value
 */
const isEqual = (val1, val2) => {
    // make sure they're the same type first
    const sameType = typeof val1 === typeof val2;
    const sameConstructor = val1.constructor.name === val2.constructor.name;
    if (!sameType || !sameConstructor)
        return false;
    // if it's an object, check nested props for equivalence
    if (typeof val1 === 'object' && typeof val2 === 'object') {
        // make sure to iterate over all the keys in both objects
        const keys = new Set([...Object.keys(val1), ...Object.keys(val2)]);
        // make sure all values are the same
        for (const key of keys) {
            const keyInBoth = key in val1 && key in val2;
            if (!keyInBoth)
                return false;
            const equal = isEqual(val1[key], val2[key]);
            if (!equal)
                return false;
        }
        // if no mismatches were found, the objects are equal
        return true;
    }
    else {
        // if it's NOT an object
        return val1 === val2;
    }
};
/**
 * Checks whether the given value is an object
 */
const isObject = (val) => !!val && val.toString() === '[object Object]';
/**
 * Returns a clone of the given array without the last item
 */
const withoutLast = (arr) => arr.slice(0, -1);
/**
 * Trims undefined values from the beginning and end of an array
 */
const trimUndef = (_arr) => {
    const arr = [..._arr];
    // backward
    for (let i = _arr.length - 1; i >= 0; i--) {
        if (typeof _arr[i] === 'undefined')
            arr.pop();
        else
            break;
    }
    // forward
    for (const el of _arr) {
        if (typeof el === 'undefined')
            arr.shift();
        else
            break;
    }
    return arr;
};
/**
 * Gets the specific error to be thrown when the state is set directly
 */
const getStateSetError = () => new Error(`
Not allowed to set a property on the state directly.
Handle state updates by defining and dispatching actions instead.
`);
/**
 * Gets the specific error to be thrown when a computed property fails to process
 */
const getComputedError = (key, err) => new Error(`
Unable to process computed property "${String(key)}"
  - Make sure all state properties are spelled correctly.
  - If it references other computed properties, make sure they are defined before this one.
  - If both of the above are valid, see the original error below.

Original error:

${err}`);
/**
 * Gets the value at the end of the given path on the given object
 */
const getValueFromPath = (obj, path, idx = 0) => {
    // if path is empty, just return the target
    if (path.length === 0)
        return obj;
    // get prerequisite values
    const key = path[idx];
    const value = obj[key];
    const isObj = typeof value === 'object' || typeof value === 'function';
    const isLastProp = (path.length - 1) === idx;
    // throw an error if unable to follow the path to completion
    if (!isObj && !isLastProp)
        throw new TypeError('Unable to get value from path because at least one of the parent properties is not an object.');
    // if this is not the final key in the path, keep running recursively
    return isLastProp ? value : getValueFromPath(value, path, idx + 1);
};
/**
 * Returns a "POJO" (plain-old JavaScript object) from a given non-serializeable object
 */
const getPojo = (obj) => {
    // if the provided object is an array, initialize accordingly
    const initAccumulator = Array.isArray(obj) ? [] : {};
    // return a POJO reduced from the provided object
    return Object.keys(obj).reduce((pojo, key) => {
        const value = obj[key];
        // skip this property if it's a method
        if (typeof value === 'function')
            return pojo;
        // if this is an object or array, get nested POJO recursively
        pojo[key] = (isObject(value) || Array.isArray(value))
            ? getPojo(value)
            : value;
        return pojo;
    }, initAccumulator);
};
/**
 * Monkey-patches an array to capture its old and new values
 */
const patchArray = (arr, enableDevTools, mutate, callback) => {
    const patchedArray = deepClone(arr);
    // iterate over each property on the original Array prototype
    const proto = Array.prototype;
    const protoKeys = Object.getOwnPropertyNames(proto);
    for (const protoKey of protoKeys) {
        const protoVal = proto[protoKey];
        // skip this iteration if necessary
        if (typeof protoVal !== 'function')
            continue;
        if (protoKey.startsWith('__'))
            continue;
        if (protoKey === 'constructor')
            continue;
        // assign a method based on the original prototype
        patchedArray[protoKey] = (...args) => {
            let result = null;
            mutate(arr, arr, (previouslyMutated) => {
                if (enableDevTools || !previouslyMutated) {
                    // capture the old and new arrays
                    const oldArray = deepClone(arr);
                    result = protoVal.call(arr, ...args);
                    const newArray = deepClone(arr);
                    // only run the callback if something changed
                    if (!isEqual(oldArray, newArray)) {
                        callback(oldArray, newArray);
                    }
                }
                else {
                    result = protoVal.call(arr, ...args);
                    callback(null, arr);
                }
            });
            // return the result of the original prototype method
            return result;
        };
    }
    // return the fully patched array
    return patchedArray;
};/**
 * Get properties as "add watcher" methods so the end user can react to state changes
 */
var getWatchers = ({ getters }, { userDefinedWatchers }) => {
    // create a closure so we have access to the path in the reducer
    const getReducer = (_path = []) => (watchers, key) => {
        const path = [..._path, key];
        // define the add watcher method
        const addWatcher = (callback) => {
            userDefinedWatchers.get(addWatcher)?.add(callback);
        };
        const _watchers = new Set();
        userDefinedWatchers.set(addWatcher, _watchers);
        watchers[key] = addWatcher;
        watchers[key].destroy = (watcher) => new Promise(resolve => {
            // use 0 timeout to avoid interfering with async actions
            setTimeout(() => {
                resolve(_watchers.delete(watcher));
            });
        });
        // if the getter value is an object, recursively add child properties
        const value = getValueFromPath(getters, path);
        if (isObject(value)) {
            const nestedWatchers = Object.keys(value).reduce(getReducer(path), {});
            const currentWatcherObj = watchers[key];
            for (const key in nestedWatchers) {
                currentWatcherObj[key] = nestedWatchers[key];
            }
        }
        // return the resulting object
        return watchers;
    };
    // kick off the reducer recursion
    return Object.keys(getters).reduce(getReducer(), {});
};const DEFAULT_HANDLER = { get: () => null, set: () => false };
/**
 * The syntax and behavior is basically the same as the native `Proxy`.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
 *
 * This one, however, proxies all child objects infinitely deep.
*/
class DeepProxy {
    constructor(target, handler = DEFAULT_HANDLER, basePath = []) {
        Object.keys(target).forEach(key => {
            const path = [...basePath, key];
            // a small utility for managing nested proxies efficiently
            const proxyUtility = {
                needsNewProxy: true,
                proxy: null,
                getProxy() {
                    if (this.needsNewProxy) {
                        this.needsNewProxy = false;
                        this.proxy = Array.isArray(target[key])
                            ? new Proxy(target[key], {
                                get: (target, key) => {
                                    const get = handler.get ?? (() => target[key]);
                                    return get(target, key, [...path, key]);
                                },
                                set: (target, key, value) => {
                                    handler.set?.(target, key, value, [...path, key]);
                                    return true;
                                },
                            })
                            : new DeepProxy(target[key], handler, path);
                    }
                    return this.proxy;
                }
            };
            const get = () => {
                if (key === '__isProxy')
                    return true;
                const defaultGetter = () => target[key];
                const getter = handler.get || defaultGetter;
                return getter(target, key, path);
            };
            const set = (newValue) => {
                // check if this change requires setting
                // a new proxy for the getter.
                proxyUtility.needsNewProxy = isObject(newValue) || Array.isArray(newValue);
                const defaultSetter = () => target[key] = newValue;
                const setter = handler.set || defaultSetter;
                setter(target, key, newValue, path);
            };
            // only use the provided getter on non-objects.
            // This avoids problems with getters overriding the DeepProxy on child objects.
            const proxyGetter = () => {
                const valueIsObject = isObject(target[key]) || Array.isArray(target[key]);
                return valueIsObject ? proxyUtility.getProxy() : get();
            };
            Object.defineProperty(this, key, { enumerable: true, get: proxyGetter, set });
        });
    }
}
// the only purpose this serves is to get rid of the class import inside State.ts,
// because Jest evidently hates classes. A lot.
const createDeepProxy = (target, handler) => new DeepProxy(target, handler);/**
 * Get all the value getters from the state - which cannot be used to set the state
 */
var getGetters = (protectedState, computed) => {
    // proxy can only get values, but will throw an error when trying to set
    const getters = createDeepProxy(protectedState, { set: () => { throw getStateSetError(); } });
    // add computed values to the getters proxy as well
    for (const key in computed) {
        Object.defineProperty(getters, key, {
            enumerable: true,
            get: () => {
                // if this property exists as a computed value...
                if (key in computed) {
                    try {
                        return computed[key](getters);
                    }
                    catch (err) {
                        throw getComputedError(key, err);
                    }
                }
            },
            set: () => { throw getStateSetError(); },
        });
    }
    // return both types of getters as one object
    return getters;
};/**
 * Prepares the runWatchers function with prerequisite data and a closure
 */
var getRunWatchers = (name, computed, publicInstance, { userDefinedWatchers, enableDevTools }) => {
    // store previous values from computed properties
    const { getters } = publicInstance;
    const prevComputed = Object.keys(computed).reduce((acc, cKey) => {
        const cValue = getters[cKey];
        acc[cKey] = Array.isArray(cValue) ? JSON.stringify(cValue) : cValue;
        return acc;
    }, {});
    /**
     * The runWatchers function triggers user-defined watcher methods for the given property
     */
    return (target, path, _newValue) => {
        const { getters, watchers } = publicInstance;
        // handle array watchers by passing the entire array
        // instead of just the one value in the array
        const parent = getValueFromPath(getters, path);
        const newValue = Array.isArray(target) ? parent : _newValue;
        const watcherValue = Array.isArray(newValue) ? trimUndef(newValue) : newValue;
        // call the watchers directly attached to this property (and its parents)
        for (const idxStr in path) {
            // build the current full path of this iteration
            const idx = Number(idxStr);
            const _path = [];
            for (let i = 0; i <= idx; i++) {
                _path.push(path[i]);
            }
            // call the watchers at the current path
            const addWatcher = getValueFromPath(watchers, _path);
            const _watchers = userDefinedWatchers.get(addWatcher) ?? new Set();
            _watchers.forEach(watcher => watcher(watcherValue, () => { addWatcher.destroy(watcher); }));
        }
        // call the watchers of all computed properties that use this property
        for (const cKey in computed) {
            const cValue = getters[cKey];
            const _cValue = Array.isArray(cValue) ? JSON.stringify(cValue) : cValue;
            if (prevComputed[cKey] === _cValue)
                continue;
            const cWatchers = userDefinedWatchers.get(watchers[cKey]) ?? new Set();
            cWatchers.forEach(watcher => watcher(cValue, destroyWatcher => destroyWatcher(watcher)));
            // tell the browser extension about the new computed value
            if (!enableDevTools || typeof window === 'undefined')
                continue;
            window.postMessage({
                type: 'thunderState_computed',
                message: {
                    stateName: name,
                    key: cKey,
                    value: cValue,
                },
            }, '*');
        }
    };
};/**
 * Get state as setters so we can intercept the mutations as they occur.
 */
var getSetters = (name, protectedState, computed, publicInstance, privateProps) => {
    const { enableDevTools } = privateProps;
    // a reusable function to add a mutation to the action entry in the history
    const recordHistory = (oldValue, newValue, path, { recordMutations, actionHistory }) => {
        if (!recordMutations || !enableDevTools)
            return;
        actionHistory[0].mutations.push({
            oldValue: deepClone(oldValue),
            newValue: deepClone(newValue),
            path,
        });
    };
    // track mutations within the current event loop to prevent
    // single mutations from triggering more than once.
    const mutated = new Map();
    const mutate = (target, newValue, mutateCallback) => {
        // if this isn't an array, run the mutation without extras
        if (!Array.isArray(target)) {
            mutateCallback();
            // refresh the getters proxy if this was an array reassignment
            if (Array.isArray(newValue)) {
                publicInstance.getters = getGetters(protectedState, computed);
            }
        }
        // run the mutation, pass in the "previously mutated" boolean
        mutateCallback(mutated.get(target));
        // set mutated boolean for the current thread
        mutated.set(target, true);
        // reset mutated boolean at the end of the event loop
        setTimeout(() => {
            mutated.set(target, false);
        }, 0);
    };
    // seal and proxy the state so it's non-extensible and intercepts mutations
    return Object.seal(createDeepProxy(protectedState, {
        get: (target, key, path) => {
            // if this isn't an array, just return the value normally
            const targetIsArray = Array.isArray(target);
            const valueIsArray = Array.isArray(target[key]);
            if (!targetIsArray && !valueIsArray)
                return target[key];
            // prepare watchers before mutating the state
            const runWatchers = getRunWatchers(name, computed, publicInstance, privateProps);
            // monkey-patch array methods to intercept mutations
            const arr = valueIsArray ? target[key] : target;
            const patchedArray = patchArray(arr, enableDevTools, mutate, (oldArray, newArray) => {
                const watcherPath = withoutLast(path);
                recordHistory(oldArray, newArray, watcherPath, privateProps);
                runWatchers(arr, watcherPath, newArray);
            });
            // return the monkey-patched array
            return valueIsArray ? patchedArray : patchedArray[key];
        },
        set: (target, key, newValue, path) => {
            const oldValue = target[key];
            // do nothing if there is nothing to change
            if (oldValue === newValue)
                return true;
            // prepare watchers before mutating the state
            const runWatchers = getRunWatchers(name, computed, publicInstance, privateProps);
            // track the mutation in the action history
            recordHistory(oldValue, newValue, path, privateProps);
            // apply the mutation
            mutate(target, newValue, () => {
                target[key] = newValue;
            });
            // trigger the watchers for all impacted properties
            const watcherPath = Array.isArray(target) ? withoutLast(path) : path;
            runWatchers(target, watcherPath, newValue);
            // if this mutation happened as a result of time travel,
            // turn "record mutations" back on
            privateProps.recordMutations = true;
            // indicate success
            return true;
        }
    }));
};/**
 * Get dispatchers for each user-defined action
 */
var getDispatchers = (name, actions, publicInstance, { setters, queue, actionHistory, enableDevTools }) => {
    return Object.keys(actions).reduce((dispatchers, key) => {
        // define the dispatcher method corresponding to the action
        dispatchers[key] = async (payload) => {
            const action = actions[key];
            // append this action as a promise to the queue
            let done = () => { };
            queue.push(new Promise(resolve => done = resolve));
            if (queue.length > 100)
                queue.shift();
            // wait for the previous action to complete before resolving the current one
            const len = queue.length;
            await (len > 1 ? queue[len - 2] : Promise.resolve());
            const actionEntry = { name: key, payload, mutations: [] };
            actionHistory.unshift(actionEntry);
            // run the user-defined action and pass in the necessary arguments
            await action({
                state: setters,
                getters: publicInstance.getters,
                dispatchers: publicInstance.dispatchers,
                payload,
            }, done);
            // if the done function was not defined as a parameter, automatically call it
            if (action.length < 2)
                done();
            await queue[len - 1];
            // tell the browser extension about the action and its mutations
            if (!enableDevTools || typeof window === 'undefined')
                return;
            window.postMessage({
                type: 'thunderState_action',
                message: {
                    stateName: name,
                    name: actionEntry.name,
                    mutations: actionEntry.mutations,
                },
            }, '*');
        };
        // return all the dispatchers as an object
        return dispatchers;
    }, {});
};/**
 * The "time travel" function used to rewind and fast-forward actions
 */
var timeTravel = (num, privateProps) => {
    const { setters, actionHistory, actionFuture } = privateProps;
    // rewind if num is negative
    const isRewinding = num < 0;
    // get all relevant numbers for comparisons and conditions
    const absNum = Math.abs(num);
    const maxNum = isRewinding ? actionHistory.length : actionFuture.length;
    const finalIdx = absNum >= maxNum ? maxNum - 1
        : absNum > 0 ? absNum - 1 : 0;
    // clone the list of actions so they can be modified during iterations
    // without causing problems with the rest of the loop
    const actions = isRewinding ? [...actionHistory] : [...actionFuture];
    // using `some` so it stops iterating when the threshold is reached
    actions.some((action, idx) => {
        // determine which lists we're moving to and from
        const fromActions = isRewinding ? actionHistory : actionFuture;
        const toActions = isRewinding ? actionFuture : actionHistory;
        // undo or redo all of this action's mutations
        action.mutations.forEach(mutation => {
            // stop recording mutations so the setters don't overwrite the action history
            privateProps.recordMutations = false;
            // get a reference to the property in question
            const { oldValue, newValue, path } = mutation;
            const parentPath = path.length > 1 ? path.slice(0, path.length - 1) : [];
            const lastKey = path[path.length - 1];
            const ref = getValueFromPath(setters, parentPath);
            // apply the mutation to the state
            ref[lastKey] = isRewinding ? deepClone(oldValue) : deepClone(newValue);
        });
        // move the action from one list to the other
        fromActions.shift();
        toActions.unshift(action);
        // stop iterating when the threshold is reached
        return idx === finalIdx;
    });
};/**
 * Prepares the "Thunder State Dev Tools" browser extension.
 */
var connectToDevTools = (name, { getters }, privateProps) => {
    // if not using browser, can't connect to dev tools; skip
    if (typeof window === 'undefined')
        return;
    // send the initial state to the browser extension
    window.postMessage({
        type: 'thunderState_initState',
        message: {
            stateName: name,
            state: getPojo(getters),
        }
    }, '*');
    // update the state if time traveled from extension
    window.addEventListener('message', ({ data, source }) => {
        const dataIsValid = source === window && isObject(data);
        // do nothing if the type or name doesn't match
        const { type, stateName, message } = data;
        const isType = dataIsValid && type === 'thunderState_timeTravel';
        if (!isType || stateName !== name)
            return;
        // establish direction and amount, then do time travel
        const { index, isRewinding } = message;
        const lastIdx = isRewinding ? (index > 0 ? -index : -1) : index + 1;
        timeTravel(lastIdx, privateProps);
    });
};// The factory function for creating a new state
const createStore = (config) => {
    // clone so the user can't modify the state from the object reference they fed in
    const { state: protectedState = {}, computed = {}, actions = {}, name, enableDevTools = true, } = deepClone(config);
    // keep a reference to the returned object
    const publicInstance = Object.seal({
        getters: {},
        watchers: {},
        dispatchers: {},
    });
    // establish an internal state for tracking things privately
    const privateProps = {
        setters: {},
        queue: [],
        actionHistory: [],
        actionFuture: [],
        recordMutations: true,
        userDefinedWatchers: new Map(),
        enableDevTools: enableDevTools === true,
    };
    // add getters to the public instance so they can be accessed externally
    publicInstance.getters = getGetters(protectedState, computed);
    // group "add watcher" methods corresponding to each property,
    // so the end user can react to state changes
    publicInstance.watchers = getWatchers(publicInstance, privateProps);
    // setters are not accessible externally; they are injected via action methods
    privateProps.setters = getSetters(name, protectedState, computed, publicInstance, privateProps);
    // add dispatchers for each action defined in the state config
    publicInstance.dispatchers = getDispatchers(name, actions, publicInstance, privateProps);
    // connect to the browser dev tools extension
    if (privateProps.enableDevTools)
        connectToDevTools(name, publicInstance, privateProps);
    // return the public object
    return publicInstance;
};exports.createStore=createStore;//# sourceMappingURL=thunderState.min.js.map
