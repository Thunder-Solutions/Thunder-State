{"version":3,"file":"simpleState.min.mjs","sources":["../lib/utilities.js","../lib/DeepProxy.js","../lib/State.js"],"sourcesContent":["/**\r\n * Checks an old value against a new value. If it is an\r\n * object which has changed, or it has just become an object,\r\n * this will return true.\r\n */ \r\nexport const getObjectChanged = (oldValue, newValue) => {\r\n\r\n  const getObjectDiff = (oldObj, newObj) => {\r\n    const oldIsObject = typeof oldObj === 'object'\r\n    const newIsObject = typeof newObj === 'object'\r\n    if (!newIsObject) return []\r\n    const newKeys = Object.keys(newObj)\r\n    return oldIsObject && newIsObject\r\n      ? newKeys.filter(key => !(key in oldObj))\r\n      : newKeys\r\n  }\r\n  \r\n  const getDeepObjectDiff = (oldObj, newObj) => {\r\n    const diff = getObjectDiff(oldObj, newObj)\r\n    const deepDiff = [...diff]\r\n    diff.forEach(key =>\r\n      deepDiff.push(...getDeepObjectDiff(oldObj[key], newObj[key])))\r\n    return deepDiff\r\n  }\r\n\r\n  return !!getDeepObjectDiff(oldValue, newValue).length\r\n}","import { getObjectChanged } from './utilities.js'\r\n\r\n/** \r\n * The syntax and behavior is basically the same as the native `Proxy`.\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\r\n * This one, however, proxies all child objects infinitely deep.\r\n*/\r\nexport default class DeepProxy {\r\n  constructor(\r\n    target = {},\r\n    handler = {},\r\n  ) {\r\n\r\n    Object.keys(target).forEach(key => {\r\n\r\n      // a small utility for managing nested proxies efficiently\r\n      const ProxyUtility = {\r\n        needsNewProxy: true,\r\n        proxy: null,\r\n        getProxy() {\r\n          if (this.needsNewProxy) {\r\n            this.needsNewProxy = false\r\n            this.proxy = new DeepProxy(target[key], handler)\r\n          }\r\n          return this.proxy\r\n        }\r\n      }\r\n\r\n      const get = () => {\r\n        const defaultGetter = () => target[key]\r\n        const getter = handler.get || defaultGetter\r\n        return getter(target, key)\r\n      }\r\n\r\n      const set = newValue => {\r\n        \r\n        // check if this change requires setting\r\n        // a new proxy for the getter.\r\n        const oldValue = target[key]\r\n        ProxyUtility.needsNewProxy = getObjectChanged(oldValue, newValue)\r\n\r\n        const defaultSetter = () => target[key] = newValue\r\n        const setter = handler.set || defaultSetter\r\n        setter(target, key, newValue)\r\n      }\r\n\r\n      // only use the provided getter on non-objects.\r\n      // This avoids problems with getters overriding the DeepProxy on child objects.\r\n      const proxyGetter = () => {\r\n        const isObject = typeof target[key] === 'object'\r\n        return isObject ? ProxyUtility.getProxy() : get()\r\n      }\r\n\r\n      Object.defineProperty(this, key, { get: proxyGetter, set })\r\n    })\r\n  }\r\n}\r\n","import DeepProxy from './DeepProxy.js'\r\n\r\nexport const getStateSetError = () => new Error(`\r\nNot allowed to set a property on the state directly.\r\nHandle state updates by defining and dispatching actions instead.\r\n`)\r\n\r\nexport const getNotActionError = type => new Error(`\r\n${JSON.stringify(type)} is not an action.\r\nMake sure the action was passed into the State constructor.\r\n`)\r\n\r\n\r\nexport default class State {\r\n  constructor({\r\n    state = {},\r\n    actions = {},\r\n    debugVariable,\r\n  }) {\r\n    const queue = []\r\n    const actionHistory = []\r\n    const actionFuture = []\r\n    let recordMutations = true\r\n\r\n    // set up setters\r\n    const stateProxy = new DeepProxy(\r\n      state,\r\n      { set: (target, key, value) => {\r\n        if (recordMutations) {\r\n          const mutation = {value: target[key], ref: [target, key]}\r\n          actionHistory[0].mutations.push(mutation)\r\n        }\r\n        target[key] = value\r\n        recordMutations = true\r\n      }}\r\n    )\r\n    Object.seal(stateProxy)\r\n\r\n    // set up getters\r\n    this.getters = new DeepProxy(\r\n      state,\r\n      { set: () => {\r\n        throw getStateSetError()\r\n      }}\r\n    )\r\n\r\n    // set up actions\r\n    const doAsyncAction = async (action, actionEntry, done) => {\r\n\r\n      // wait for the previous action to complete before resolving the current one\r\n      const len = queue.length\r\n      await (len > 1 ? queue[len - 2] : Promise.resolve())\r\n      actionHistory.unshift(actionEntry)\r\n      action({\r\n        state: stateProxy,\r\n        payload: actionEntry.payload,\r\n      }, done)\r\n\r\n      // if the done function was not defined as a parameter, automatically call it\r\n      if (action.length < 2) done()\r\n      await queue[len - 1]\r\n    }\r\n\r\n    // set up dispatcher\r\n    this.dispatch = (name, payload) => {\r\n      const actionExists = Object.keys(actions).some(\r\n        existingAction => existingAction === name)\r\n      if (!actionExists) throw getNotActionError(name)\r\n      const actionEntry = {name, payload, mutations: []}\r\n\r\n      // append this action as a promise to the queue\r\n      let done\r\n      queue.push(new Promise(resolve => done = resolve))\r\n      if (queue.length > 100) queue.shift()\r\n\r\n      // wait for the action to complete before modifying the history\r\n      return doAsyncAction(actions[name], actionEntry, done)\r\n    }\r\n\r\n    // set up debugging tools only if in debug mode\r\n    if (!debugVariable) return Object.freeze(this)\r\n\r\n    // set up time travel\r\n    this.timeTravel = num => {\r\n      const isRewinding = num < 0\r\n      const absNum = Math.abs(num)\r\n      const maxNum = isRewinding ? actionHistory.length : actionFuture.length\r\n      const finalIdx =\r\n        absNum >= maxNum ? maxNum - 1\r\n        : absNum > 0 ? absNum - 1 : 0\r\n      const actions = isRewinding ? [...actionHistory] : [...actionFuture]\r\n\r\n      actions.some((action, idx) => {\r\n        const fromActions = isRewinding ? actionHistory : actionFuture\r\n        const toActions = isRewinding ? actionFuture : actionHistory\r\n\r\n        action.mutations.forEach(mutation => {\r\n          const [target, key] = mutation.ref\r\n          recordMutations = false\r\n          const oldVal = target[key]\r\n          target[key] = mutation.value\r\n          mutation.value = oldVal\r\n        })\r\n        fromActions.shift()\r\n        toActions.unshift(action)\r\n\r\n        return idx === finalIdx\r\n      })\r\n    }\r\n\r\n    // don't allow the dev to misuse the state object\r\n    window[debugVariable] = Object.freeze(this)\r\n  }\r\n}"],"names":["getObjectChanged","oldValue","newValue","getDeepObjectDiff","oldObj","newObj","diff","oldIsObject","_typeof","newIsObject","newKeys","Object","keys","filter","key","getObjectDiff","deepDiff","forEach","push","length","DeepProxy","target","handler","ProxyUtility","needsNewProxy","proxy","getProxy","this","defineProperty","_this","get","set","State","state","actions","debugVariable","queue","actionHistory","actionFuture","recordMutations","stateProxy","value","mutation","ref","mutations","seal","getters","Error","doAsyncAction","action","actionEntry","done","len","Promise","resolve","unshift","payload","dispatch","name","type","some","existingAction","JSON","stringify","shift","freeze","timeTravel","num","isRewinding","absNum","Math","abs","maxNum","finalIdx","idx","fromActions","toActions","oldVal","window"],"mappings":"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"}