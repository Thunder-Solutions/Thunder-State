{"version":3,"file":"thunderState.min.mjs","sources":["../lib/utilities.js","../lib/DeepProxy.js","../lib/getGetters.js","../lib/getSetters.js","../lib/getRunWatchers.js","../lib/getDispatchers.js","../lib/getTimeTravel.js","../lib/State.js","../lib/getWatchers.js"],"sourcesContent":["export const isObject = val => Object.prototype.toString.call(val) === '[object Object]'\r\nexport const withoutLast = arr => arr.slice(0, arr.length - 1)\r\nexport const trimUndef = _arr => {\r\n  const arr = [..._arr]\r\n\r\n  // backward\r\n  for (let i = _arr.length - 1; i >= 0; i--) {\r\n    if (typeof _arr[i] === 'undefined') arr.pop()\r\n    else break\r\n  }\r\n\r\n  // forward\r\n  for (const el of _arr) {\r\n    if (typeof el === 'undefined') arr.shift()\r\n    else break\r\n  }\r\n\r\n  return arr\r\n}\r\n\r\n/**\r\n * Checks an old value against a new value. If it is an\r\n * object which has changed, or it has just become an object,\r\n * this will return true.\r\n */ \r\nexport const getObjectChanged = (oldValue, newValue) => {\r\n\r\n  const getObjectDiff = (oldObj, newObj) => {\r\n    const oldIsObject = isObject(oldObj)\r\n    const newIsObject = isObject(newObj)\r\n    if (!newIsObject) return []\r\n    const newKeys = Object.keys(newObj)\r\n    return oldIsObject && newIsObject\r\n      ? newKeys.filter(key => !(key in oldObj))\r\n      : newKeys\r\n  }\r\n  \r\n  const getDeepObjectDiff = (oldObj, newObj) => {\r\n    const diff = getObjectDiff(oldObj, newObj)\r\n    const deepDiff = [...diff]\r\n    diff.forEach(key =>\r\n      deepDiff.push(...getDeepObjectDiff(oldObj[key], newObj[key])))\r\n    return deepDiff\r\n  }\r\n\r\n  return !!getDeepObjectDiff(oldValue, newValue).length\r\n}\r\n\r\nexport const getStateSetError = () => new Error(`\r\nNot allowed to set a property on the state directly.\r\nHandle state updates by defining and dispatching actions instead.\r\n`)\r\n\r\nexport const getValueFromPath = (obj, path, idx = 0) => {\r\n  if (path.length === 0) return obj\r\n  const key = path[idx]\r\n  const value = obj[key]\r\n  const isObj = isObject(value)\r\n  const isLastProp = (path.length - 1) === idx\r\n  if (!isObj && !isLastProp) throw new TypeError(\r\n'Unable to get value from path because at least one of the properties is not an object.')\r\n  return isLastProp ? value : getValueFromPath(value, path, idx + 1)\r\n}\r\n\r\nexport const getPojo = obj => {\r\n  const pojo = Object.keys(obj).reduce((pojo, key) => {\r\n    const value = obj[key]\r\n    pojo[key] = (isObject(value) || Array.isArray(value))\r\n      ? getPojo(value)\r\n      : value\r\n    return pojo\r\n  }, Array.isArray(obj) ? [] : {})\r\n  return pojo\r\n}\r\n","import { getObjectChanged, getStateSetError, isObject } from './utilities.js'\r\n\r\n/** \r\n * The syntax and behavior is basically the same as the native `Proxy`.\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\r\n * This one, however, proxies all child objects infinitely deep.\r\n*/\r\nexport class DeepProxy {\r\n  constructor(\r\n    target = {},\r\n    handler = {},\r\n    basePath = [],\r\n  ) {\r\n\r\n    Object.keys(target).forEach(key => {\r\n      const path = [...basePath, key]\r\n\r\n      // a small utility for managing nested proxies efficiently\r\n      const ProxyUtility = {\r\n        needsNewProxy: true,\r\n        proxy: null,\r\n        getProxy() {\r\n          if (this.needsNewProxy) {\r\n            this.needsNewProxy = false\r\n            this.proxy = Array.isArray(target[key])\r\n              ? new Proxy(target[key], {\r\n                get: handler.get,\r\n                set: (target, key, value) => {\r\n                  return handler.set(target, key, value, [...path, key])\r\n                },\r\n              })\r\n              : new DeepProxy(target[key], handler, path)\r\n          }\r\n          return this.proxy\r\n        }\r\n      }\r\n\r\n      const get = () => {\r\n        if (key === '__isProxy') return true\r\n        const defaultGetter = () => target[key]\r\n        const getter = handler.get || defaultGetter\r\n        return getter(target, key, path)\r\n      }\r\n\r\n      const set = newValue => {\r\n        \r\n        // check if this change requires setting\r\n        // a new proxy for the getter.\r\n        const oldValue = target[key]\r\n        ProxyUtility.needsNewProxy = getObjectChanged(oldValue, newValue)\r\n\r\n        const defaultSetter = () => target[key] = newValue\r\n        const setter = handler.set || defaultSetter\r\n        setter(target, key, newValue, path)\r\n      }\r\n\r\n      // only use the provided getter on non-objects.\r\n      // This avoids problems with getters overriding the DeepProxy on child objects.\r\n      const proxyGetter = () => {\r\n        const valueIsObject = isObject(target[key]) || Array.isArray(target[key])\r\n        return valueIsObject ? ProxyUtility.getProxy() : get()\r\n      }\r\n\r\n      Object.defineProperty(this, key, { enumerable: true, get: proxyGetter, set })\r\n    })\r\n  }\r\n}\r\n\r\nexport const createImmutableProxy = obj => new DeepProxy(\r\n  obj,\r\n  { set: () => {\r\n    throw getStateSetError()\r\n  }}\r\n)\r\n\r\n// the only purpose this serves is to get rid of the class import inside State.js,\r\n// because Jest evidently hates classes. A lot.\r\nexport const createDeepProxy = (target, handler) => new DeepProxy(target, handler)\r\n","import { createImmutableProxy } from './DeepProxy'\r\nimport { getStateSetError } from './utilities'\r\n\r\n/**\r\n * Get all the value getters from the state - which cannot be used to set the state\r\n * @param {object} state - The mutable state from the original `new State()` config object\r\n * @param {object} computed - The dynamic values from the original `new State()` config object\r\n * @returns {object} - all immutable getters as a combined object\r\n */\r\nexport default (state, computed) => {\r\n\r\n  // proxy can only get values, but will throw an error when trying to set\r\n  const getters = createImmutableProxy(state)\r\n\r\n  // turn all computed values into getters that behave the same way as above\r\n  const computedGetters = Object.keys(computed).reduce((computedGetters, key) => {\r\n    Object.defineProperty(computedGetters, key, {\r\n      enumerable: true,\r\n      get: () => computed[key](getters),\r\n      set: () => { throw getStateSetError() },\r\n    })\r\n    return computedGetters\r\n  }, {})\r\n\r\n  // return both types of getters as one object\r\n  return {\r\n    ...getters,\r\n    ...computedGetters,\r\n  }\r\n}\r\n","import { createDeepProxy } from './DeepProxy'\r\nimport getRunWatchers from './getRunWatchers'\r\n\r\n/**\r\n * Get state as setters so we can intercept the mutations as they occur.\r\n * @param {object} state - The mutable state from the original `new State()` config object\r\n * @param {object} computed - The dynamic values from the original `new State()` config object\r\n * @param {object} stateRef - A reference to the full constructed instance from `new State()`\r\n * @param {object} internalState - The state used to track various things privately\r\n * @returns {object} - A non-extensible object used to set values on the state\r\n */\r\nexport default (state, computed, stateRef, internalState) => Object.seal(createDeepProxy(\r\n  state,\r\n  {\r\n    set: (target, key, newValue, path) => {\r\n      const oldValue = target[key]\r\n\r\n      // do nothing if there is nothing to change\r\n      if (oldValue === newValue) return true\r\n\r\n      // prepare watchers before mutating the state\r\n      const runWatchers = getRunWatchers(computed, stateRef, internalState)\r\n\r\n      // track the mutation in the action history\r\n      const { recordMutations, actionHistory } = internalState\r\n      if (recordMutations) {\r\n        const mutation = {oldValue, newValue, path}\r\n        actionHistory[0].mutations.push(mutation)\r\n      }\r\n\r\n      // apply the mutation\r\n      target[key] = newValue\r\n\r\n      // trigger the watchers for all impacted properties\r\n      runWatchers(target, path, newValue)\r\n\r\n      // if this mutation happened as a result of time travel,\r\n      // turn \"record mutations\" back on\r\n      internalState.recordMutations = true\r\n\r\n      // indicate success\r\n      return true\r\n    }\r\n  }\r\n))\r\n","import { getValueFromPath, trimUndef, withoutLast } from './utilities'\r\n\r\n/**\r\n * Prepares the runWatchers function with prerequisite data and a closure\r\n * @param {object} computed - The dynamic values from the original `new State()` config object\r\n * @param {object} stateRef - A reference to the full constructed instance from `new State()`\r\n * @param {object} stateRef.getters - The immutable getters; attempting to set throws an error\r\n * @param {object} internalState - The state used to track various things privately\r\n * @param {Map} internalState.userDefinedWatchers - Map to track watchers with \"add watcher\" methods used as keys\r\n * @returns {function} - the runWatchers function\r\n */\r\nexport default (computed, { getters, watchers }, { userDefinedWatchers }) => {\r\n\r\n  // store previous values from computed properties\r\n  const prevComputed = Object.keys(computed).reduce((acc, cKey) => {\r\n    acc[cKey] = getters[cKey]\r\n    return acc\r\n  }, {})\r\n\r\n  /**\r\n   * The runWatchers function triggers user-defined watcher methods for the given property\r\n   * @param {object|Array} target - The parent object of the property being changed\r\n   * @param {Array<string>} path - The object key path of the property being changed\r\n   * @param {*} newValue - The new value being assigned to the given property\r\n   */\r\n  return (target, path, newValue) => {\r\n\r\n    // handle array watchers by passing the entire array\r\n    // instead of just the one value in the array\r\n    const isArray = Array.isArray(target)\r\n    const watcherPath = isArray\r\n      ? withoutLast(path)\r\n      : path\r\n    const watcherValue = isArray\r\n      ? trimUndef(getValueFromPath(getters, watcherPath))\r\n      : newValue\r\n\r\n    // define destroy function for cleanup\r\n    const destroyWatcher = (_watchers, ref) => {\r\n      const idx = _watchers.findIndex(watcher => watcher === ref)\r\n\r\n      // use 0 timeout to avoid interfering with the current stack\r\n      setTimeout(() => _watchers.splice(idx, 1), 0)\r\n    }\r\n\r\n    // call the watchers directly attached to this property\r\n    const addWatcher = getValueFromPath(watchers, watcherPath)\r\n    const _watchers = userDefinedWatchers.get(addWatcher)\r\n    _watchers.forEach(watcher =>\r\n      watcher(watcherValue, () => destroyWatcher(_watchers, watcher)))\r\n\r\n    // call the watchers of all computed properties that use this property\r\n    Object.keys(computed).forEach(cKey => {\r\n      const cValue = getters[cKey]\r\n      if (prevComputed[cKey] === cValue) return\r\n      const cAddWatcher = watchers[cKey]\r\n      const _cWatchers = userDefinedWatchers.get(cAddWatcher)\r\n      _cWatchers.forEach(watcher =>\r\n        watcher(cValue, () => destroyWatcher(_cWatchers, watcher)))\r\n    })\r\n  }\r\n}\r\n","/**\r\n * Get dispatchers for each user-defined action\r\n * @param {string} name - The name of the state instance\r\n * @param {object} actions - The action methods from the original `new State()` config object\r\n * @param {object} setters - A non-extensible object used to set values on the state\r\n * @param {object} internalState - The state used to track various things privately\r\n * @param {Array<Promise>} queue - The backlog of async actions\r\n * @param {Array<object>} actionHistory - A list of previously dispatched actions\r\n * @returns {object} - All dispatchers corresponding with each user-defined action\r\n */\r\nexport default (name, actions, setters, { queue, actionHistory }) => {\r\n  return Object.keys(actions).reduce((dispatchers, key) => {\r\n\r\n    // define the dispatcher method corresponding to the action\r\n    dispatchers[key] = async payload => {\r\n      const action = actions[key]\r\n      \r\n      // append this action as a promise to the queue\r\n      let done\r\n      queue.push(new Promise(resolve => done = resolve))\r\n      if (queue.length > 100) queue.shift()\r\n\r\n      // wait for the previous action to complete before resolving the current one\r\n      const len = queue.length\r\n      await (len > 1 ? queue[len - 2] : Promise.resolve())\r\n      const actionEntry = {name: key, payload, mutations: []}\r\n      actionHistory.unshift(actionEntry)\r\n\r\n      // run the user-defined action and pass in the necessary arguments\r\n      await action({\r\n        state: setters,\r\n        payload,\r\n      }, done)\r\n\r\n      // if the done function was not defined as a parameter, automatically call it\r\n      if (action.length < 2) done()\r\n      await queue[len - 1]\r\n\r\n      // tell the browser extension about the action and its mutations\r\n      if (typeof window === 'undefined') return\r\n      window.postMessage({\r\n        type: 'thunderState_action',\r\n        message: {\r\n          stateName: name,\r\n          name: actionEntry.name,\r\n          mutations: actionEntry.mutations,\r\n        },\r\n      }, '*')\r\n    }\r\n\r\n    // return all the dispatchers as an object\r\n    return dispatchers\r\n  }, {})\r\n}","import { getValueFromPath } from './utilities'\r\n\r\nexport default internalState => num => {\r\n  const { actionHistory, actionFuture } = internalState\r\n  const isRewinding = num < 0\r\n  const absNum = Math.abs(num)\r\n  const maxNum = isRewinding ? actionHistory.length : actionFuture.length\r\n  const finalIdx =\r\n    absNum >= maxNum ? maxNum - 1\r\n    : absNum > 0 ? absNum - 1 : 0\r\n  const actions = isRewinding ? [...actionHistory] : [...actionFuture]\r\n\r\n  actions.some((action, idx) => {\r\n    const fromActions = isRewinding ? actionHistory : actionFuture\r\n    const toActions = isRewinding ? actionFuture : actionHistory\r\n\r\n    action.mutations.forEach(mutation => {\r\n      internalState.recordMutations = false\r\n      const { oldValue, newValue, path } = mutation\r\n      const parentPath = path.length > 1 ? path.slice(0, path.length - 1) : []\r\n      const lastKey = path[path.length - 1]\r\n      const ref = getValueFromPath(setters, parentPath)\r\n      ref[lastKey] = isRewinding ? oldValue : newValue\r\n    })\r\n    fromActions.shift()\r\n    toActions.unshift(action)\r\n\r\n    return idx === finalIdx\r\n  })\r\n}\r\n","import getWatchers from './getWatchers'\r\nimport { getValueFromPath, isObject, getPojo } from './utilities'\r\nimport getGetters from './getGetters'\r\nimport getSetters from './getSetters'\r\nimport getDispatchers from './getDispatchers'\r\nimport getTimeTravel from './getTimeTravel'\r\n\r\nexport default class State {\r\n  constructor({\r\n    state = {},\r\n    computed = {},\r\n    actions = {},\r\n    name,\r\n  }) {\r\n    const stateRef = this\r\n\r\n    // establish an internal state for tracking things privately\r\n    const internalState = {\r\n      queue: [],\r\n      actionHistory: [],\r\n      actionFuture: [],\r\n      recordMutations: true,\r\n      userDefinedWatchers: new Map(),\r\n    }\r\n\r\n    // add getters to the state so they can be accessed externally\r\n    const getters = stateRef.getters = getGetters(state, computed)\r\n\r\n    // group \"add watcher\" methods corresponding to each property,\r\n    // so the end user can react to state changes\r\n    stateRef.watchers = getWatchers(getters, internalState)\r\n\r\n    // setters are not accessible externally, except via action methods\r\n    const setters = getSetters(state, computed, stateRef, internalState)\r\n\r\n    // add dispatchers for each action defined in the state config\r\n    stateRef.dispatchers = getDispatchers(name, actions, setters, internalState)\r\n\r\n    // if no window exists, skip this section\r\n    if (typeof window === 'undefined') return\r\n\r\n    // send the initial state to the browser extension\r\n    window.postMessage({\r\n      type: 'thunderState_initState',\r\n      message: {\r\n        stateName: name,\r\n        state: getPojo(stateRef.getters),\r\n      }\r\n    }, '*')\r\n\r\n    // set up time travel\r\n    const timeTravel = getTimeTravel(internalState)\r\n\r\n    // update the state if time traveled from extension\r\n    window.addEventListener('message', event => {\r\n      const data = event.data\r\n      const dataIsObject = data && isObject(data)\r\n      const dataIsValid = event.source === window && dataIsObject\r\n      const {type, stateName, message} = data\r\n      const isType = dataIsValid && type === 'thunderState_timeTravel'\r\n      if (!isType || stateName !== name) return\r\n      const {index, isRewinding} = message\r\n      const lastIdx = isRewinding ? (index > 0 ? -index : -1) : index + 1\r\n      timeTravel(lastIdx)\r\n    })\r\n\r\n  }\r\n}\r\n","import { getValueFromPath, isObject } from \"./utilities\"\r\n\r\n/**\r\n * Get properties as \"add watcher\" methods so the end user can react to state changes\r\n * @param {object} getters - The immutable getters; attempting to set throws an error\r\n * @param {object} internalState - The state used to track various things privately\r\n * @param {Map} internalState.userDefinedWatchers - Map to track watchers with \"add watcher\" methods used as keys\r\n * @returns {object} - All the \"add watcher\" methods corresponding to every property on the state\r\n */\r\nexport default (getters, { userDefinedWatchers }) => {\r\n\r\n  // create a closure so we have access to the path in the reducer\r\n  const getReducer = (_path = []) => (watchers, key) => {\r\n    const path = [..._path, key]\r\n\r\n    // define the add watcher method\r\n    const addWatcher = callback => {\r\n      userDefinedWatchers.get(addWatcher).push(callback)\r\n    }\r\n    userDefinedWatchers.set(addWatcher, [])\r\n    watchers[key] = addWatcher\r\n\r\n    // if the getter value is an object, recursively add child properties\r\n    const value = getValueFromPath(getters, path)\r\n    if (isObject(value)) {\r\n      return Object.keys(value).reduce(getReducer(path), {})\r\n    }\r\n\r\n    // return the resulting object\r\n    return watchers\r\n  }\r\n\r\n  // kick off the reducer recursion\r\n  return Object.keys(getters).reduce(getReducer(), {})\r\n}\r\n"],"names":["isObject","val","Object","prototype","toString","call","trimUndef","_arr","arr","i","length","pop","shift","getObjectChanged","oldValue","newValue","getDeepObjectDiff","oldObj","newObj","diff","oldIsObject","newIsObject","newKeys","keys","filter","key","getObjectDiff","deepDiff","forEach","push","getStateSetError","Error","getValueFromPath","obj","path","idx","value","isObj","isLastProp","TypeError","getPojo","reduce","pojo","Array","isArray","DeepProxy","target","handler","basePath","ProxyUtility","needsNewProxy","proxy","getProxy","this","Proxy","get","set","defineProperty","_this","enumerable","state","computed","getters","computedGetters","stateRef","internalState","seal","runWatchers","watchers","userDefinedWatchers","prevComputed","acc","cKey","watcherPath","slice","watcherValue","destroyWatcher","_watchers","ref","findIndex","watcher","setTimeout","splice","addWatcher","cValue","cAddWatcher","_cWatchers","getRunWatchers","recordMutations","actionHistory","mutation","mutations","name","actions","setters","queue","dispatchers","payload","action","Promise","resolve","done","len","actionEntry","unshift","window","postMessage","type","message","stateName","num","actionFuture","isRewinding","absNum","Math","abs","maxNum","finalIdx","some","fromActions","toActions","parentPath","lastKey","State","Map","getGetters","getReducer","_path","callback","getWatchers","getSetters","getDispatchers","timeTravel","getTimeTravel","addEventListener","event","data","dataIsObject","dataIsValid","source","index"],"mappings":"k4PAAO,IAAMA,EAAW,SAAAC,SAA+C,oBAAxCC,OAAOC,UAAUC,SAASC,KAAKJ,IAEjDK,EAAY,SAAAC,WACjBC,IAAUD,GAGPE,EAAIF,EAAKG,OAAS,EAAGD,GAAK,QACV,IAAZF,EAAKE,GADoBA,IACAD,EAAIG,4oBAKzBJ,kCAAM,SACH,YACb,MAD0BC,EAAII,8CAI9BJ,GAQIK,EAAmB,SAACC,EAAUC,WAYf,SAApBC,EAAqBC,EAAQC,OAC3BC,EAXc,SAACF,EAAQC,OACvBE,EAAcpB,EAASiB,GACvBI,EAAcrB,EAASkB,OACxBG,EAAa,MAAO,OACnBC,EAAUpB,OAAOqB,KAAKL,UACrBE,GAAeC,EAClBC,EAAQE,QAAO,SAAAC,WAASA,KAAOR,MAC/BK,EAISI,CAAcT,EAAQC,GAC7BS,IAAeR,UACrBA,EAAKS,SAAQ,SAAAH,UACXE,EAASE,WAATF,IAAiBX,EAAkBC,EAAOQ,GAAMP,EAAOO,SAClDE,EAGAX,CAAkBF,EAAUC,GAAUL,QAGpCoB,EAAmB,kBAAM,IAAIC,sIAK7BC,EAAmB,SAAnBA,EAAoBC,EAAKC,OAAMC,yDAAM,KAC5B,IAAhBD,EAAKxB,OAAc,OAAOuB,MACxBR,EAAMS,EAAKC,GACXC,EAAQH,EAAIR,GACZY,EAAQrC,EAASoC,GACjBE,EAAcJ,EAAKxB,OAAS,IAAOyB,MACpCE,IAAUC,EAAY,MAAM,IAAIC,UACvC,iGACSD,EAAaF,EAAQJ,EAAiBI,EAAOF,EAAMC,EAAM,IAGrDK,EAAU,SAAVA,EAAUP,UACR/B,OAAOqB,KAAKU,GAAKQ,QAAO,SAACC,EAAMjB,OACpCW,EAAQH,EAAIR,UAClBiB,EAAKjB,GAAQzB,EAASoC,IAAUO,MAAMC,QAAQR,GAC1CI,EAAQJ,GACRA,EACGM,IACNC,MAAMC,QAAQX,GAAO,GAAK,KChElBY,EACX,wBACEC,yDAAS,GACTC,yDAAU,GACVC,yDAAW,aAGX9C,OAAOqB,KAAKuB,GAAQlB,SAAQ,SAAAH,OACpBS,cAAWc,IAAUvB,IAGrBwB,EAAe,CACnBC,eAAe,EACfC,MAAO,KACPC,2BACMC,KAAKH,qBACFA,eAAgB,OAChBC,MAAQR,MAAMC,QAAQE,EAAOrB,IAC9B,IAAI6B,MAAMR,EAAOrB,GAAM,CACvB8B,IAAKR,EAAQQ,IACbC,IAAK,SAACV,EAAQrB,EAAKW,UACVW,EAAQS,IAAIV,EAAQrB,EAAKW,cAAWF,IAAMT,QAGnD,IAAIoB,EAAUC,EAAOrB,GAAMsB,EAASb,IAEnCmB,KAAKF,QA8BhBjD,OAAOuD,eAAeC,EAAMjC,EAAK,CAAEkC,YAAY,EAAMJ,IALjC,kBACIvD,EAAS8C,EAAOrB,KAASkB,MAAMC,QAAQE,EAAOrB,IAC7CwB,EAAaG,WAtBxB,cAAR3B,IAEWsB,EAAQQ,KADD,kBAAMT,EAAOrB,KAErBqB,EAAQrB,EAAKS,IAsB0CsB,IAnB3D,SAAAzC,OAIJD,EAAWgC,EAAOrB,GACxBwB,EAAaC,cAAgBrC,EAAiBC,EAAUC,IAGzCgC,EAAQS,KADD,kBAAMV,EAAOrB,GAAOV,IAEnC+B,EAAQrB,EAAKV,EAAUmB,qBC5CtB0B,EAAOC,OAGfC,EDwDmC,IAAIjB,ECxDRe,ED0DrC,CAAEJ,IAAK,iBACC1B,OCxDFiC,EAAkB7D,OAAOqB,KAAKsC,GAAUpB,QAAO,SAACsB,EAAiBtC,UACrEvB,OAAOuD,eAAeM,EAAiBtC,EAAK,CAC1CkC,YAAY,EACZJ,IAAK,kBAAMM,EAASpC,GAAKqC,IACzBN,IAAK,iBAAc1B,OAEdiC,IACN,kBAIED,GACAC,eChBSH,EAAOC,EAAUG,EAAUC,UAAkB/D,OAAOgE,MFkE5BnB,EEhEtC,CACES,IAAK,SAACV,EAAQrB,EAAKV,EAAUmB,OACrBpB,EAAWgC,EAAOrB,MAGpBX,IAAaC,EAAU,OAAO,MAG5BoD,WCVIN,WAAYC,IAAAA,QAASM,IAAAA,SAAcC,IAAAA,oBAG3CC,EAAepE,OAAOqB,KAAKsC,GAAUpB,QAAO,SAAC8B,EAAKC,UACtDD,EAAIC,GAAQV,EAAQU,GACbD,IACN,WAQI,SAACzB,EAAQZ,EAAMnB,OJxBGP,EI4BjBoC,EAAUD,MAAMC,QAAQE,GACxB2B,EAAc7B,GJ7BGpC,EI8BP0B,GJ9BkBwC,MAAM,EAAGlE,EAAIE,OAAS,GI+BpDwB,EACEyC,EAAe/B,EACjBtC,EAAU0B,EAAiB8B,EAASW,IACpC1D,EAGE6D,EAAiB,SAACC,EAAWC,OAC3B3C,EAAM0C,EAAUE,WAAU,SAAAC,UAAWA,IAAYF,KAGvDG,YAAW,kBAAMJ,EAAUK,OAAO/C,EAAK,KAAI,IAIvCgD,EAAanD,EAAiBoC,EAAUK,GACxCI,EAAYR,EAAoBd,IAAI4B,GAC1CN,EAAUjD,SAAQ,SAAAoD,UAChBA,EAAQL,GAAc,kBAAMC,EAAeC,EAAWG,SAGxD9E,OAAOqB,KAAKsC,GAAUjC,SAAQ,SAAA4C,OACtBY,EAAStB,EAAQU,MACnBF,EAAaE,KAAUY,OACrBC,EAAcjB,EAASI,GACvBc,EAAajB,EAAoBd,IAAI8B,GAC3CC,EAAW1D,SAAQ,SAAAoD,UACjBA,EAAQI,GAAQ,kBAAMR,EAAeU,EAAYN,cDrC/BO,CAAe1B,EAAUG,EAAUC,GAG/CuB,EAAmCvB,EAAnCuB,gBAAiBC,EAAkBxB,EAAlBwB,iBACrBD,EAAiB,KACbE,EAAW,CAAC5E,SAAAA,EAAUC,SAAAA,EAAUmB,KAAAA,GACtCuD,EAAc,GAAGE,UAAU9D,KAAK6D,UAIlC5C,EAAOrB,GAAOV,EAGdoD,EAAYrB,EAAQZ,EAAMnB,GAI1BkD,EAAcuB,iBAAkB,GAGzB,IFoCuC,IAAI3C,EEjEtDe,EFiEwEb,KAA3C,IAASA,cInExB6C,EAAMC,EAASC,SAAWC,IAAAA,MAAON,IAAAA,qBACxCvF,OAAOqB,KAAKsE,GAASpD,QAAO,SAACuD,EAAavE,UAG/CuE,EAAYvE,kDAAO,WAAMwE,sGACjBC,EAASL,EAAQpE,GAIvBsE,EAAMlE,KAAK,IAAIsE,SAAQ,SAAAC,UAAWC,EAAOD,MACrCL,EAAMrF,OAAS,KAAKqF,EAAMnF,QAGxB0F,EAAMP,EAAMrF,gBACX4F,EAAM,EAAIP,EAAMO,EAAM,GAAKH,QAAQC,wBACpCG,EAAc,CAACX,KAAMnE,EAAKwE,QAAAA,EAASN,UAAW,IACpDF,EAAce,QAAQD,aAGhBL,EAAO,CACXtC,MAAOkC,EACPG,QAAAA,GACCI,kBAGCH,EAAOxF,OAAS,GAAG2F,cACjBN,EAAMO,EAAM,cAGI,oBAAXG,0DACXA,OAAOC,YAAY,CACjBC,KAAM,sBACNC,QAAS,CACPC,UAAWjB,EACXA,KAAMW,EAAYX,KAClBD,UAAWY,EAAYZ,YAExB,qRAIEK,IACN,gBClDU/B,UAAiB,SAAA6C,OACtBrB,EAAgCxB,EAAhCwB,cAAesB,EAAiB9C,EAAjB8C,aACjBC,EAAcF,EAAM,EACpBG,EAASC,KAAKC,IAAIL,GAClBM,EAASJ,EAAcvB,EAAc/E,OAASqG,EAAarG,OAC3D2G,EACJJ,GAAUG,EAASA,EAAS,EAC1BH,EAAS,EAAIA,EAAS,EAAI,IACdD,EAAkBvB,EAAqBsB,GAE/CO,MAAK,SAACpB,EAAQ/D,OACdoF,EAAcP,EAAcvB,EAAgBsB,EAC5CS,EAAYR,EAAcD,EAAetB,SAE/CS,EAAOP,UAAU/D,SAAQ,SAAA8D,GACvBzB,EAAcuB,iBAAkB,MACxB1E,EAA6B4E,EAA7B5E,SAAUC,EAAmB2E,EAAnB3E,SAAUmB,EAASwD,EAATxD,KACtBuF,EAAavF,EAAKxB,OAAS,EAAIwB,EAAKwC,MAAM,EAAGxC,EAAKxB,OAAS,GAAK,GAChEgH,EAAUxF,EAAKA,EAAKxB,OAAS,GACvBsB,EAAiB8D,QAAS2B,GAClCC,GAAWV,EAAclG,EAAWC,KAE1CwG,EAAY3G,QACZ4G,EAAUhB,QAAQN,GAEX/D,IAAQkF,OCpBEM,EACnB,sBACE/D,MAAAA,aAAQ,SACRC,SAAAA,aAAW,SACXgC,QAAAA,aAAU,KACVD,IAAAA,mBAEM5B,EAAWX,KAGXY,EAAgB,CACpB8B,MAAO,GACPN,cAAe,GACfsB,aAAc,GACdvB,iBAAiB,EACjBnB,oBAAqB,IAAIuD,KAIrB9D,EAAUE,EAASF,QAAU+D,EAAWjE,EAAOC,GAIrDG,EAASI,kBCrBGN,SAAWO,IAAAA,2BAwBlBnE,OAAOqB,KAAKuC,GAASrB,OArBT,SAAbqF,QAAcC,yDAAQ,UAAO,SAAC3D,EAAU3C,OACtCS,cAAW6F,IAAOtG,IAGlB0D,EAAa,SAAbA,EAAa6C,GACjB3D,EAAoBd,IAAI4B,GAAYtD,KAAKmG,IAE3C3D,EAAoBb,IAAI2B,EAAY,IACpCf,EAAS3C,GAAO0D,MAGV/C,EAAQJ,EAAiB8B,EAAS5B,UACpClC,EAASoC,GACJlC,OAAOqB,KAAKa,GAAOK,OAAOqF,EAAW5F,GAAO,IAI9CkC,GAI0B0D,GAAc,IDH3BG,CAAYnE,EAASG,OAGnC6B,EAAUoC,EAAWtE,EAAOC,EAAUG,EAAUC,MAGtDD,EAASgC,YAAcmC,EAAevC,EAAMC,EAASC,EAAS7B,GAGxC,oBAAXwC,QAGXA,OAAOC,YAAY,CACjBC,KAAM,yBACNC,QAAS,CACPC,UAAWjB,EACXhC,MAAOpB,EAAQwB,EAASF,WAEzB,SAGGsE,EAAaC,EAAcpE,GAGjCwC,OAAO6B,iBAAiB,WAAW,SAAAC,OAC3BC,EAAOD,EAAMC,KACbC,EAAeD,GAAQxI,EAASwI,GAChCE,EAAcH,EAAMI,SAAWlC,QAAUgC,EACxC9B,EAA4B6B,EAA5B7B,KAAME,EAAsB2B,EAAtB3B,UAAWD,EAAW4B,EAAX5B,WACT8B,GAAwB,4BAAT/B,GACfE,IAAcjB,OACtBgD,EAAsBhC,EAAtBgC,MAAO5B,EAAeJ,EAAfI,YAEdoB,EADgBpB,EAAe4B,EAAQ,GAAKA,GAAS,EAAKA,EAAQ"}