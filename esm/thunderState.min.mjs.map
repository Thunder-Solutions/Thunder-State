{"version":3,"file":"thunderState.min.mjs","sources":["../lib/utilities.js","../lib/DeepProxy.js","../lib/getGetters.js","../lib/getSetters.js","../lib/getRunWatchers.js","../lib/State.js","../lib/getWatchers.js"],"sourcesContent":["export const isObject = val => Object.prototype.toString.call(val) === '[object Object]'\r\nexport const withoutLast = arr => arr.slice(0, arr.length - 1)\r\nexport const trimUndef = _arr => {\r\n  const arr = [..._arr]\r\n\r\n  // backward\r\n  for (let i = _arr.length - 1; i >= 0; i--) {\r\n    if (typeof _arr[i] === 'undefined') arr.pop()\r\n    else break\r\n  }\r\n\r\n  // forward\r\n  for (const el of _arr) {\r\n    if (typeof el === 'undefined') arr.shift()\r\n    else break\r\n  }\r\n\r\n  return arr\r\n}\r\n\r\n/**\r\n * Checks an old value against a new value. If it is an\r\n * object which has changed, or it has just become an object,\r\n * this will return true.\r\n */ \r\nexport const getObjectChanged = (oldValue, newValue) => {\r\n\r\n  const getObjectDiff = (oldObj, newObj) => {\r\n    const oldIsObject = isObject(oldObj)\r\n    const newIsObject = isObject(newObj)\r\n    if (!newIsObject) return []\r\n    const newKeys = Object.keys(newObj)\r\n    return oldIsObject && newIsObject\r\n      ? newKeys.filter(key => !(key in oldObj))\r\n      : newKeys\r\n  }\r\n  \r\n  const getDeepObjectDiff = (oldObj, newObj) => {\r\n    const diff = getObjectDiff(oldObj, newObj)\r\n    const deepDiff = [...diff]\r\n    diff.forEach(key =>\r\n      deepDiff.push(...getDeepObjectDiff(oldObj[key], newObj[key])))\r\n    return deepDiff\r\n  }\r\n\r\n  return !!getDeepObjectDiff(oldValue, newValue).length\r\n}\r\n\r\nexport const getStateSetError = () => new Error(`\r\nNot allowed to set a property on the state directly.\r\nHandle state updates by defining and dispatching actions instead.\r\n`)\r\n\r\nexport const getValueFromPath = (obj, path, idx = 0) => {\r\n  if (path.length === 0) return obj\r\n  const key = path[idx]\r\n  const value = obj[key]\r\n  const isObj = isObject(value)\r\n  const isLastProp = (path.length - 1) === idx\r\n  if (!isObj && !isLastProp) throw new TypeError(\r\n'Unable to get value from path because at least one of the properties is not an object.')\r\n  return isLastProp ? value : getValueFromPath(value, path, idx + 1)\r\n}\r\n","import { getObjectChanged, getStateSetError, isObject } from './utilities.js'\r\n\r\n/** \r\n * The syntax and behavior is basically the same as the native `Proxy`.\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\r\n * This one, however, proxies all child objects infinitely deep.\r\n*/\r\nexport class DeepProxy {\r\n  constructor(\r\n    target = {},\r\n    handler = {},\r\n    basePath = [],\r\n  ) {\r\n\r\n    Object.keys(target).forEach(key => {\r\n      const path = [...basePath, key]\r\n\r\n      // a small utility for managing nested proxies efficiently\r\n      const ProxyUtility = {\r\n        needsNewProxy: true,\r\n        proxy: null,\r\n        getProxy() {\r\n          if (this.needsNewProxy) {\r\n            this.needsNewProxy = false\r\n            this.proxy = Array.isArray(target[key])\r\n              ? new Proxy(target[key], {\r\n                get: handler.get,\r\n                set: (target, key, value) => {\r\n                  return handler.set(target, key, value, [...path, key])\r\n                },\r\n              })\r\n              : new DeepProxy(target[key], handler, path)\r\n          }\r\n          return this.proxy\r\n        }\r\n      }\r\n\r\n      const get = () => {\r\n        if (key === '__isProxy') return true\r\n        const defaultGetter = () => target[key]\r\n        const getter = handler.get || defaultGetter\r\n        return getter(target, key, path)\r\n      }\r\n\r\n      const set = newValue => {\r\n        \r\n        // check if this change requires setting\r\n        // a new proxy for the getter.\r\n        const oldValue = target[key]\r\n        ProxyUtility.needsNewProxy = getObjectChanged(oldValue, newValue)\r\n\r\n        const defaultSetter = () => target[key] = newValue\r\n        const setter = handler.set || defaultSetter\r\n        setter(target, key, newValue, path)\r\n      }\r\n\r\n      // only use the provided getter on non-objects.\r\n      // This avoids problems with getters overriding the DeepProxy on child objects.\r\n      const proxyGetter = () => {\r\n        const valueIsObject = isObject(target[key]) || Array.isArray(target[key])\r\n        return valueIsObject ? ProxyUtility.getProxy() : get()\r\n      }\r\n\r\n      Object.defineProperty(this, key, { enumerable: true, get: proxyGetter, set })\r\n    })\r\n  }\r\n}\r\n\r\nexport const createImmutableProxy = obj => new DeepProxy(\r\n  obj,\r\n  { set: () => {\r\n    throw getStateSetError()\r\n  }}\r\n)\r\n\r\n// the only purpose this serves is to get rid of the class import inside State.js,\r\n// because Jest evidently hates classes. A lot.\r\nexport const createDeepProxy = (target, handler) => new DeepProxy(target, handler)\r\n","import { createImmutableProxy } from './DeepProxy'\r\nimport { getStateSetError } from './utilities'\r\n\r\n/**\r\n * Get all the value getters from the state - which cannot be used to set the state\r\n * @param {object} state - The mutable state from the original `new State()` config object\r\n * @param {object} computed - The dynamic values from the original `new State()` config object\r\n * @returns {object} - all immutable getters as a combined object\r\n */\r\nexport default (state, computed) => {\r\n\r\n  // proxy can only get values, but will throw an error when trying to set\r\n  const getters = createImmutableProxy(state)\r\n\r\n  // turn all computed values into getters that behave the same way as above\r\n  const computedGetters = Object.keys(computed).reduce((computedGetters, key) => {\r\n    Object.defineProperty(computedGetters, key, {\r\n      enumerable: true,\r\n      get: () => computed[key](getters),\r\n      set: () => { throw getStateSetError() },\r\n    })\r\n    return computedGetters\r\n  }, {})\r\n\r\n  // return both types of getters as one object\r\n  return {\r\n    ...getters,\r\n    ...computedGetters,\r\n  }\r\n}\r\n","import { createDeepProxy } from './DeepProxy'\r\nimport getRunWatchers from './getRunWatchers'\r\n\r\n/**\r\n * Get state as setters so we can intercept the mutations as they occur.\r\n * @param {object} state - The mutable state from the original `new State()` config object\r\n * @param {object} computed - The dynamic values from the original `new State()` config object\r\n * @returns {object} - A non-extensible object used to set values on the state\r\n */\r\nexport default (state, computed, stateRef, internalState) => Object.seal(createDeepProxy(\r\n  state,\r\n  {\r\n    set: (target, key, newValue, path) => {\r\n      const oldValue = target[key]\r\n\r\n      // do nothing if there is nothing to change\r\n      if (oldValue === newValue) return true\r\n\r\n      // prepare watchers before mutating the state\r\n      const runWatchers = getRunWatchers(computed, stateRef, internalState)\r\n\r\n      // track the mutation in the action history\r\n      const { recordMutations, actionHistory } = internalState\r\n      if (recordMutations) {\r\n        const mutation = {oldValue, newValue, path}\r\n        actionHistory[0].mutations.push(mutation)\r\n      }\r\n\r\n      // apply the mutation\r\n      target[key] = newValue\r\n\r\n      // trigger the watchers for all impacted properties\r\n      runWatchers(target, path, newValue)\r\n\r\n      // if this mutation happened as a result of time travel,\r\n      // turn \"record mutations\" back on\r\n      internalState.recordMutations = true\r\n\r\n      // indicate success\r\n      return true\r\n    }\r\n  }\r\n))\r\n","import { getValueFromPath, trimUndef, withoutLast } from './utilities'\r\n\r\n/**\r\n * Prepares the runWatchers function with prerequisite data and a closure\r\n * @param {object} computed - The dynamic values from the original `new State()` config object\r\n * @param {object} stateRef - A reference to the full constructed instance from `new State()`\r\n * @param {object} stateRef.getters - The immutable getters; attempting to set throws an error\r\n * @returns {function} - the runWatchers function\r\n */\r\nexport default (computed, { getters, watchers }, { userDefinedWatchers }) => {\r\n\r\n  // store previous values from computed properties\r\n  const prevComputed = Object.keys(computed).reduce((acc, cKey) => {\r\n    acc[cKey] = getters[cKey]\r\n    return acc\r\n  }, {})\r\n\r\n  /**\r\n   * The runWatchers function triggers user-defined watcher methods for the given property\r\n   * @param {object|Array} target - The parent object of the property being changed\r\n   * @param {Array<string>} path - The object key path of the property being changed\r\n   * @param {*} newValue - The new value being assigned to the given property\r\n   */\r\n  return (target, path, newValue) => {\r\n\r\n    // handle array watchers by passing the entire array\r\n    // instead of just the one value in the array\r\n    const isArray = Array.isArray(target)\r\n    const watcherPath = isArray\r\n      ? withoutLast(path)\r\n      : path\r\n    const watcherValue = isArray\r\n      ? trimUndef(getValueFromPath(getters, watcherPath))\r\n      : newValue\r\n\r\n    // define destroy function for cleanup\r\n    const destroyWatcher = (_watchers, ref) => {\r\n      const idx = _watchers.findIndex(watcher => watcher === ref)\r\n\r\n      // use 0 timeout to avoid interfering with the current stack\r\n      setTimeout(() => _watchers.splice(idx, 1), 0)\r\n    }\r\n\r\n    // call the watchers directly attached to this property\r\n    const addWatcher = getValueFromPath(watchers, watcherPath)\r\n    const _watchers = userDefinedWatchers.get(addWatcher)\r\n    _watchers.forEach(watcher =>\r\n      watcher(watcherValue, () => destroyWatcher(_watchers, watcher)))\r\n\r\n    // call the watchers of all computed properties that use this property\r\n    Object.keys(computed).forEach(cKey => {\r\n      const cValue = getters[cKey]\r\n      if (prevComputed[cKey] === cValue) return\r\n      const cAddWatcher = watchers[cKey]\r\n      const _cWatchers = userDefinedWatchers.get(cAddWatcher)\r\n      _cWatchers.forEach(watcher =>\r\n        watcher(cValue, () => destroyWatcher(_cWatchers, watcher)))\r\n    })\r\n  }\r\n}\r\n","import getWatchers from './getWatchers'\r\nimport { getValueFromPath, isObject } from './utilities.js'\r\nimport getGetters from './getGetters.js'\r\nimport getSetters from './getSetters.js'\r\n\r\nexport default class State {\r\n  constructor({\r\n    state = {},\r\n    computed = {},\r\n    actions = {},\r\n    name,\r\n  }) {\r\n    const stateRef = this\r\n\r\n    const internalState = {\r\n      queue: [],\r\n      actionHistory: [],\r\n      actionFuture: [],\r\n      recordMutations: true,\r\n      userDefinedWatchers: new Map(),\r\n    }\r\n\r\n    // add getters to the state so they can be accessed externally\r\n    const getters = stateRef.getters = getGetters(state, computed)\r\n\r\n    // setters are not accessible externally, except via action methods\r\n    const setters = getSetters(state, computed, stateRef, internalState)\r\n\r\n    // set up watchers\r\n    stateRef.watchers = getWatchers(getters, internalState)\r\n\r\n    // set up actions\r\n    const doAsyncAction = async (action, actionEntry, done) => {\r\n\r\n      const { queue, actionHistory } = internalState\r\n\r\n      // wait for the previous action to complete before resolving the current one\r\n      const len = queue.length\r\n      await (len > 1 ? queue[len - 2] : Promise.resolve())\r\n      actionHistory.unshift(actionEntry)\r\n\r\n      // run the user-defined action and pass in the necessary arguments\r\n      action({\r\n        state: setters,\r\n        payload: actionEntry.payload,\r\n      }, done)\r\n\r\n      // if the done function was not defined as a parameter, automatically call it\r\n      if (action.length < 2) done()\r\n      await queue[len - 1]\r\n\r\n      const { mutations } = actionEntry\r\n\r\n      if (typeof window === 'undefined') return\r\n      window.postMessage({\r\n        type: 'thunderState_action',\r\n        message: {\r\n          stateName: name,\r\n          name: action.name,\r\n          mutations,\r\n        },\r\n      }, '*')\r\n    }\r\n\r\n    // set up dispatchers\r\n    stateRef.dispatchers = {}\r\n    Object.keys(actions).forEach(name => {\r\n      stateRef.dispatchers[name] = payload => {\r\n        const actionEntry = {name, payload, mutations: []}\r\n        const { queue } = internalState\r\n\r\n        // append this action as a promise to the queue\r\n        let done\r\n        queue.push(new Promise(resolve => done = resolve))\r\n        if (queue.length > 100) queue.shift()\r\n\r\n        // wait for the action to complete before modifying the history\r\n        return doAsyncAction(actions[name], actionEntry, done)\r\n      }\r\n    })\r\n\r\n    // set up time travel\r\n    const timeTravel = num => {\r\n      const { actionHistory, actionFuture } = internalState\r\n      const isRewinding = num < 0\r\n      const absNum = Math.abs(num)\r\n      const maxNum = isRewinding ? actionHistory.length : actionFuture.length\r\n      const finalIdx =\r\n        absNum >= maxNum ? maxNum - 1\r\n        : absNum > 0 ? absNum - 1 : 0\r\n      const actions = isRewinding ? [...actionHistory] : [...actionFuture]\r\n\r\n      actions.some((action, idx) => {\r\n        const fromActions = isRewinding ? actionHistory : actionFuture\r\n        const toActions = isRewinding ? actionFuture : actionHistory\r\n\r\n        action.mutations.forEach(mutation => {\r\n          internalState.recordMutations = false\r\n          const { oldValue, newValue, path } = mutation\r\n          const parentPath = path.length > 1 ? path.slice(0, path.length - 1) : []\r\n          const lastKey = path[path.length - 1]\r\n          const ref = getValueFromPath(setters, parentPath)\r\n          ref[lastKey] = isRewinding ? oldValue : newValue\r\n        })\r\n        fromActions.shift()\r\n        toActions.unshift(action)\r\n\r\n        return idx === finalIdx\r\n      })\r\n    }\r\n\r\n    // evaluate all the getters to get a JSON-ifiable object\r\n    const evaluateGetters = (getters, asArray = false) => {\r\n      const accumulator = asArray ? [] : {}\r\n      const evaluatedGetters = Object.keys(getters).reduce((accumulator, key) => {\r\n        const evaluatedResult = getters[key]\r\n        const isArray = Array.isArray(evaluatedResult)\r\n        const isObjOrArr = evaluatedResult\r\n          && (isObject(evaluatedResult.constructor) || isArray)\r\n        accumulator[key] = isObjOrArr\r\n          ? evaluateGetters(evaluatedResult, isArray)\r\n          : evaluatedResult\r\n        return accumulator\r\n      }, accumulator)\r\n      return evaluatedGetters\r\n    }\r\n\r\n    // if no window exists, skip this section\r\n    if (typeof window === 'undefined') return\r\n\r\n    // send the initial state to the browser extension\r\n    window.postMessage({\r\n      type: 'thunderState_initState',\r\n      message: {\r\n        stateName: name,\r\n        state: evaluateGetters(stateRef.getters),\r\n      }\r\n    }, '*')\r\n\r\n    // update the state if time traveled from extension\r\n    window.addEventListener('message', event => {\r\n      const data = event.data\r\n      const dataIsObject = data && isObject(data)\r\n      const dataIsValid = event.source === window && dataIsObject\r\n      const {type, stateName, message} = data\r\n      const isType = dataIsValid && type === 'thunderState_timeTravel'\r\n      if (!isType || stateName !== name) return\r\n      const {index, isRewinding} = message\r\n      const lastIdx = isRewinding ? (index > 0 ? -index : -1) : index + 1\r\n      timeTravel(lastIdx)\r\n    })\r\n\r\n  }\r\n}\r\n","import { getValueFromPath, isObject } from \"./utilities\"\r\n\r\n/**\r\n * Get properties as \"add watcher\" methods so the end user can react to state changes\r\n * @param {object} getters - The immutable getters; attempting to set throws an error\r\n * @param {object} internalState - The state used to track various things privately\r\n * @param {Map} internalState.userDefinedWatchers - Map to track watchers with \"add watcher\" methods used as keys\r\n * @returns {object} - All the \"add watcher\" methods corresponding to every property on the state\r\n */\r\nexport default (getters, { userDefinedWatchers }) => {\r\n\r\n  // create a closure so we have access to the path in the reducer\r\n  const getReducer = (_path = []) => (watchers, key) => {\r\n    const path = [..._path, key]\r\n\r\n    // define the add watcher method\r\n    const addWatcher = callback => {\r\n      userDefinedWatchers.get(addWatcher).push(callback)\r\n    }\r\n    userDefinedWatchers.set(addWatcher, [])\r\n    watchers[key] = addWatcher\r\n\r\n    // if the getter value is an object, recursively add child properties\r\n    const value = getValueFromPath(getters, path)\r\n    if (isObject(value)) {\r\n      return Object.keys(value).reduce(getReducer(path), {})\r\n    }\r\n\r\n    // return the resulting object\r\n    return watchers\r\n  }\r\n\r\n  // kick off the reducer recursion\r\n  return Object.keys(getters).reduce(getReducer(), {})\r\n}\r\n"],"names":["isObject","val","Object","prototype","toString","call","trimUndef","_arr","arr","i","length","pop","shift","getObjectChanged","oldValue","newValue","getDeepObjectDiff","oldObj","newObj","diff","oldIsObject","newIsObject","newKeys","keys","filter","key","getObjectDiff","deepDiff","forEach","push","getStateSetError","Error","getValueFromPath","obj","path","idx","value","isObj","isLastProp","TypeError","DeepProxy","target","handler","basePath","ProxyUtility","needsNewProxy","proxy","getProxy","this","Array","isArray","Proxy","get","set","defineProperty","_this","enumerable","state","computed","getters","computedGetters","reduce","stateRef","internalState","seal","runWatchers","watchers","userDefinedWatchers","prevComputed","acc","cKey","watcherPath","slice","watcherValue","destroyWatcher","_watchers","ref","findIndex","watcher","setTimeout","splice","addWatcher","cValue","cAddWatcher","_cWatchers","getRunWatchers","recordMutations","actionHistory","mutation","mutations","State","actions","name","queue","actionFuture","Map","getGetters","setters","getSetters","getReducer","_path","callback","getWatchers","doAsyncAction","action","actionEntry","done","len","Promise","resolve","unshift","payload","window","postMessage","type","message","stateName","dispatchers","evaluateGetters","asArray","accumulator","evaluatedGetters","evaluatedResult","isObjOrArr","constructor","addEventListener","event","data","dataIsObject","dataIsValid","source","index","num","isRewinding","absNum","Math","abs","maxNum","finalIdx","some","fromActions","toActions","parentPath","lastKey","timeTravel"],"mappings":"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"}