{"version":3,"file":"thunderState.min.mjs","sources":["../lib/utilities.js","../lib/DeepProxy.js","../lib/getGetters.js","../lib/getSetters.js","../lib/getRunWatchers.js","../lib/getDispatchers.js","../lib/connectToDevTools.js","../lib/timeTravel.js","../lib/State.js","../lib/getWatchers.js","../src/index.js"],"sourcesContent":["\r\n/**\r\n * Checks whether the given value is an object\r\n * @param {*} val - The value to test\r\n * @returns {boolean} - True if the value is an object\r\n */\r\nexport const isObject = val => Object.prototype.toString.call(val) === '[object Object]'\r\n\r\n/**\r\n * Returns a clone of the given array without the last item\r\n * @param {Array} arr - The reference array\r\n * @returns {Array} - A copy of the array without the last item\r\n */\r\nexport const withoutLast = arr => arr.slice(0, arr.length - 1)\r\n\r\n/**\r\n * Trims undefined values from the beginning and end of an array\r\n * @param {Array} _arr - The reference array\r\n * @returns {Array} - A trimmed copy of the array\r\n */\r\nexport const trimUndef = _arr => {\r\n  const arr = [..._arr]\r\n\r\n  // backward\r\n  for (let i = _arr.length - 1; i >= 0; i--) {\r\n    if (typeof _arr[i] === 'undefined') arr.pop()\r\n    else break\r\n  }\r\n\r\n  // forward\r\n  for (const el of _arr) {\r\n    if (typeof el === 'undefined') arr.shift()\r\n    else break\r\n  }\r\n\r\n  return arr\r\n}\r\n\r\n/**\r\n * Compares values to see if they are objects and whether they changed shape\r\n * @param {*} oldValue - The old value to compare\r\n * @param {*} newValue - The new value to compare\r\n * @returns {boolean} - True if the object has changed shape, or the value became an object\r\n */ \r\nexport const getObjectChanged = (oldValue, newValue) => {\r\n\r\n  // get a list of diffs\r\n  const getObjectDiff = (oldObj, newObj) => {\r\n    const oldIsObject = isObject(oldObj)\r\n    const newIsObject = isObject(newObj)\r\n\r\n    // if the new value is not an object, return 0 diffs\r\n    if (!newIsObject) return []\r\n\r\n    // return all the freshly added keys as diffs\r\n    const newObjKeys = Object.keys(newObj)\r\n    return oldIsObject && newIsObject\r\n      ? newObjKeys.filter(key => !(key in oldObj))\r\n      : newObjKeys\r\n  }\r\n  \r\n  // get a list of diffs in child properties also\r\n  const getDeepObjectDiff = (oldObj, newObj) => {\r\n    const diff = getObjectDiff(oldObj, newObj)\r\n\r\n    // check all child properties recursively\r\n    const deepDiff = [...diff]\r\n    diff.forEach(key =>\r\n      deepDiff.push(...getDeepObjectDiff(oldObj[key], newObj[key])))\r\n\r\n    // return ALL diffs\r\n    return deepDiff\r\n  }\r\n\r\n  // if there's any diffs in the list at all, return true\r\n  return !!getDeepObjectDiff(oldValue, newValue).length\r\n}\r\n\r\n/**\r\n * Gets the specific error to be thrown when the state is set directly\r\n * @returns {Error} - The error to be thrown when the state is set directly\r\n */\r\nexport const getStateSetError = () => new Error(`\r\nNot allowed to set a property on the state directly.\r\nHandle state updates by defining and dispatching actions instead.\r\n`)\r\n\r\n/**\r\n * Gets the value at the end of the given path on the given object\r\n * @param {object} obj - The reference object\r\n * @param {Array<string>} path - The list of keys to follow (from object dot-notation)\r\n * @param {number} idx - The index of the current key in the path\r\n * @returns {*} - The value at the end of the given path on the given object\r\n */\r\nexport const getValueFromPath = (obj, path, idx = 0) => {\r\n\r\n  // if path is empty, just return the target\r\n  if (path.length === 0) return obj\r\n\r\n  // get prerequisite values\r\n  const key = path[idx]\r\n  const value = obj[key]\r\n  const isObj = isObject(value)\r\n  const isLastProp = (path.length - 1) === idx\r\n\r\n  // throw an error if unable to follow the path to completion\r\n  if (!isObj && !isLastProp) throw new TypeError(\r\n'Unable to get value from path because at least one of the parent properties is not an object.')\r\n\r\n  // if this is not the final key in the path, keep running recursively\r\n  return isLastProp ? value : getValueFromPath(value, path, idx + 1)\r\n}\r\n\r\n/**\r\n * Returns a \"POJO\" (plain-old JavaScript object) from a given non-serializeable object\r\n * @param {object|Array} obj - The (potentially) non-serializeable object to convert\r\n * @returns {object} - The \"POJO\" converted from the given object\r\n */\r\nexport const getPojo = obj => {\r\n\r\n  // if the provided object is an array, initialize accordingly\r\n  const initAccumulator = Array.isArray(obj) ? [] : {}\r\n\r\n  // return a POJO reduced from the provided object\r\n  return Object.keys(obj).reduce((pojo, key) => {\r\n    const value = obj[key]\r\n\r\n    // skip this property if it's a method\r\n    if (typeof value === 'function') return pojo\r\n\r\n    // if this is an object or array, get nested POJO recursively\r\n    pojo[key] = (isObject(value) || Array.isArray(value))\r\n      ? getPojo(value)\r\n      : value\r\n    return pojo\r\n  }, initAccumulator)\r\n}\r\n","import { getObjectChanged, getStateSetError, isObject } from './utilities.js'\r\n\r\n/** \r\n * The syntax and behavior is basically the same as the native `Proxy`.\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\r\n * This one, however, proxies all child objects infinitely deep.\r\n*/\r\nexport class DeepProxy {\r\n  constructor(\r\n    target = {},\r\n    handler = {},\r\n    basePath = [],\r\n  ) {\r\n\r\n    Object.keys(target).forEach(key => {\r\n      const path = [...basePath, key]\r\n\r\n      // a small utility for managing nested proxies efficiently\r\n      const ProxyUtility = {\r\n        needsNewProxy: true,\r\n        proxy: null,\r\n        getProxy() {\r\n          if (this.needsNewProxy) {\r\n            this.needsNewProxy = false\r\n            this.proxy = Array.isArray(target[key])\r\n              ? new Proxy(target[key], {\r\n                get: handler.get,\r\n                set: (target, key, value) => {\r\n                  return handler.set(target, key, value, [...path, key])\r\n                },\r\n              })\r\n              : new DeepProxy(target[key], handler, path)\r\n          }\r\n          return this.proxy\r\n        }\r\n      }\r\n\r\n      const get = () => {\r\n        if (key === '__isProxy') return true\r\n        const defaultGetter = () => target[key]\r\n        const getter = handler.get || defaultGetter\r\n        return getter(target, key, path)\r\n      }\r\n\r\n      const set = newValue => {\r\n        \r\n        // check if this change requires setting\r\n        // a new proxy for the getter.\r\n        const oldValue = target[key]\r\n        ProxyUtility.needsNewProxy = getObjectChanged(oldValue, newValue)\r\n\r\n        const defaultSetter = () => target[key] = newValue\r\n        const setter = handler.set || defaultSetter\r\n        setter(target, key, newValue, path)\r\n      }\r\n\r\n      // only use the provided getter on non-objects.\r\n      // This avoids problems with getters overriding the DeepProxy on child objects.\r\n      const proxyGetter = () => {\r\n        const valueIsObject = isObject(target[key]) || Array.isArray(target[key])\r\n        return valueIsObject ? ProxyUtility.getProxy() : get()\r\n      }\r\n\r\n      Object.defineProperty(this, key, { enumerable: true, get: proxyGetter, set })\r\n    })\r\n  }\r\n}\r\n\r\nexport const createImmutableProxy = obj => new DeepProxy(\r\n  obj,\r\n  { set: () => {\r\n    throw getStateSetError()\r\n  }}\r\n)\r\n\r\n// the only purpose this serves is to get rid of the class import inside State.js,\r\n// because Jest evidently hates classes. A lot.\r\nexport const createDeepProxy = (target, handler) => new DeepProxy(target, handler)\r\n","import { createImmutableProxy } from './DeepProxy'\r\nimport { getStateSetError } from './utilities'\r\n\r\n/**\r\n * Get all the value getters from the state - which cannot be used to set the state\r\n * @param {object} state - The mutable state from the original `new State()` config object\r\n * @param {object} computed - The dynamic values from the original `new State()` config object\r\n * @returns {object} - all immutable getters as a combined object\r\n */\r\nexport default (state, computed) => {\r\n\r\n  // proxy can only get values, but will throw an error when trying to set\r\n  const getters = createImmutableProxy(state)\r\n\r\n  // turn all computed values into getters that behave the same way as above\r\n  const computedGetters = Object.keys(computed).reduce((computedGetters, key) => {\r\n    Object.defineProperty(computedGetters, key, {\r\n      enumerable: true,\r\n      get: () => computed[key](getters),\r\n      set: () => { throw getStateSetError() },\r\n    })\r\n    return computedGetters\r\n  }, {})\r\n\r\n  // return both types of getters as one object\r\n  return {\r\n    ...getters,\r\n    ...computedGetters,\r\n  }\r\n}\r\n","import { createDeepProxy } from './DeepProxy'\r\nimport getRunWatchers from './getRunWatchers'\r\n\r\n/**\r\n * Get state as setters so we can intercept the mutations as they occur.\r\n * @param {object} state - The mutable state from the original `new State()` config object\r\n * @param {object} computed - The dynamic values from the original `new State()` config object\r\n * @param {object} stateRef - A reference to the full constructed instance from `new State()`\r\n * @param {object} internalState - The state used to track various things privately\r\n * @returns {object} - A non-extensible object used to set values on the state\r\n */\r\nexport default (state, computed, stateRef, internalState) => Object.seal(createDeepProxy(\r\n  state,\r\n  {\r\n    set: (target, key, newValue, path) => {\r\n      const oldValue = target[key]\r\n\r\n      // do nothing if there is nothing to change\r\n      if (oldValue === newValue) return true\r\n\r\n      // prepare watchers before mutating the state\r\n      const runWatchers = getRunWatchers(computed, stateRef, internalState)\r\n\r\n      // track the mutation in the action history\r\n      const { recordMutations, actionHistory } = internalState\r\n      if (recordMutations) {\r\n        const mutation = {oldValue, newValue, path}\r\n        actionHistory[0].mutations.push(mutation)\r\n      }\r\n\r\n      // apply the mutation\r\n      target[key] = newValue\r\n\r\n      // trigger the watchers for all impacted properties\r\n      runWatchers(target, path, newValue)\r\n\r\n      // if this mutation happened as a result of time travel,\r\n      // turn \"record mutations\" back on\r\n      internalState.recordMutations = true\r\n\r\n      // indicate success\r\n      return true\r\n    }\r\n  }\r\n))\r\n","import { getValueFromPath, trimUndef, withoutLast } from './utilities'\r\n\r\n/**\r\n * Prepares the runWatchers function with prerequisite data and a closure\r\n * @param {object} computed - The dynamic values from the original `new State()` config object\r\n * @param {object} stateRef - A reference to the full constructed instance from `new State()`\r\n * @param {object} stateRef.getters - The immutable getters; attempting to set throws an error\r\n * @param {object} internalState - The state used to track various things privately\r\n * @param {Map} internalState.userDefinedWatchers - Map to track watchers with \"add watcher\" methods used as keys\r\n * @returns {function} - the runWatchers function\r\n */\r\nexport default (computed, { getters, watchers }, { userDefinedWatchers }) => {\r\n\r\n  // store previous values from computed properties\r\n  const prevComputed = Object.keys(computed).reduce((acc, cKey) => {\r\n    acc[cKey] = getters[cKey]\r\n    return acc\r\n  }, {})\r\n\r\n  /**\r\n   * The runWatchers function triggers user-defined watcher methods for the given property\r\n   * @param {object|Array} target - The parent object of the property being changed\r\n   * @param {Array<string>} path - The object key path of the property being changed\r\n   * @param {*} newValue - The new value being assigned to the given property\r\n   */\r\n  return (target, path, newValue) => {\r\n\r\n    // handle array watchers by passing the entire array\r\n    // instead of just the one value in the array\r\n    const isArray = Array.isArray(target)\r\n    const watcherPath = isArray\r\n      ? withoutLast(path)\r\n      : path\r\n    const watcherValue = isArray\r\n      ? trimUndef(getValueFromPath(getters, watcherPath))\r\n      : newValue\r\n\r\n    // define destroy function for cleanup\r\n    const destroyWatcher = (_watchers, ref) => {\r\n      const idx = _watchers.findIndex(watcher => watcher === ref)\r\n\r\n      // use 0 timeout to avoid interfering with the current stack\r\n      setTimeout(() => _watchers.splice(idx, 1), 0)\r\n    }\r\n\r\n    // call the watchers directly attached to this property\r\n    const addWatcher = getValueFromPath(watchers, watcherPath)\r\n    const _watchers = userDefinedWatchers.get(addWatcher)\r\n    _watchers.forEach(watcher =>\r\n      watcher(watcherValue, () => destroyWatcher(_watchers, watcher)))\r\n\r\n    // call the watchers of all computed properties that use this property\r\n    Object.keys(computed).forEach(cKey => {\r\n      const cValue = getters[cKey]\r\n      if (prevComputed[cKey] === cValue) return\r\n      const cAddWatcher = watchers[cKey]\r\n      const _cWatchers = userDefinedWatchers.get(cAddWatcher)\r\n      _cWatchers.forEach(watcher =>\r\n        watcher(cValue, () => destroyWatcher(_cWatchers, watcher)))\r\n    })\r\n  }\r\n}\r\n","/**\r\n * Get dispatchers for each user-defined action\r\n * @param {string} name - The name of the state instance\r\n * @param {object} actions - The action methods from the original `new State()` config object\r\n * @param {object} setters - A non-extensible object used to set values on the state\r\n * @param {object} internalState - The state used to track various things privately\r\n * @param {Array<Promise>} queue - The backlog of async actions\r\n * @param {Array<object>} actionHistory - A list of previously dispatched actions\r\n * @returns {object} - All dispatchers corresponding with each user-defined action\r\n */\r\nexport default (name, actions, setters, { queue, actionHistory }) => {\r\n  return Object.keys(actions).reduce((dispatchers, key) => {\r\n\r\n    // define the dispatcher method corresponding to the action\r\n    dispatchers[key] = async payload => {\r\n      const action = actions[key]\r\n      \r\n      // append this action as a promise to the queue\r\n      let done\r\n      queue.push(new Promise(resolve => done = resolve))\r\n      if (queue.length > 100) queue.shift()\r\n\r\n      // wait for the previous action to complete before resolving the current one\r\n      const len = queue.length\r\n      await (len > 1 ? queue[len - 2] : Promise.resolve())\r\n      const actionEntry = {name: key, payload, mutations: []}\r\n      actionHistory.unshift(actionEntry)\r\n\r\n      // run the user-defined action and pass in the necessary arguments\r\n      await action({\r\n        state: setters,\r\n        payload,\r\n      }, done)\r\n\r\n      // if the done function was not defined as a parameter, automatically call it\r\n      if (action.length < 2) done()\r\n      await queue[len - 1]\r\n\r\n      // tell the browser extension about the action and its mutations\r\n      if (typeof window === 'undefined') return\r\n      window.postMessage({\r\n        type: 'thunderState_action',\r\n        message: {\r\n          stateName: name,\r\n          name: actionEntry.name,\r\n          mutations: actionEntry.mutations,\r\n        },\r\n      }, '*')\r\n    }\r\n\r\n    // return all the dispatchers as an object\r\n    return dispatchers\r\n  }, {})\r\n}","import { isObject, getPojo } from './utilities'\r\nimport timeTravel from './timeTravel'\r\n\r\n/**\r\n * Prepares the \"Thunder State Dev Tools\" browser extension.\r\n * @param {string} name - The name of the state instance\r\n * @param {object} getters - The immutable getters; attempting to set throws an error\r\n * @param {object} internalState - The state used to track various things privately\r\n */\r\nexport default (name, getters, setters, internalState) => {\r\n\r\n  // if not using browser, can't connect to dev tools; skip\r\n  if (typeof window === 'undefined') return\r\n\r\n  // send the initial state to the browser extension\r\n  window.postMessage({\r\n    type: 'thunderState_initState',\r\n    message: {\r\n      stateName: name,\r\n      state: getPojo(getters),\r\n    }\r\n  }, '*')\r\n\r\n  // update the state if time traveled from extension\r\n  window.addEventListener('message', ({ data, source }) => {\r\n    const dataIsValid = source === window && isObject(data)\r\n\r\n    // do nothing if the type or name doesn't match\r\n    const { type, stateName, message } = data\r\n    const isType = dataIsValid && type === 'thunderState_timeTravel'\r\n    if (!isType || stateName !== name) return\r\n\r\n    // establish direction and amount, then do time travel\r\n    const { index, isRewinding } = message\r\n    const lastIdx = isRewinding ? (index > 0 ? -index : -1) : index + 1\r\n    timeTravel(lastIdx, setters, internalState)\r\n  })\r\n}\r\n","import { getValueFromPath } from './utilities'\r\n\r\n/**\r\n * The \"time travel\" function used to rewind and fast-forward actions\r\n * @param {number} num - The number of actions to move (negative for rewinding)\r\n * @param {object} internalState - The state used to track various things privately\r\n */\r\nexport default (num, setters, internalState) => {\r\n  const { actionHistory, actionFuture } = internalState\r\n\r\n  // rewind if num is negative\r\n  const isRewinding = num < 0\r\n\r\n  // get all relevant numbers for comparisons and conditions\r\n  const absNum = Math.abs(num)\r\n  const maxNum = isRewinding ? actionHistory.length : actionFuture.length\r\n  const finalIdx =\r\n    absNum >= maxNum ? maxNum - 1\r\n    : absNum > 0 ? absNum - 1 : 0\r\n  \r\n  // clone the list of actions so they can be modified during iterations\r\n  // without causing problems with the rest of the loop\r\n  const actions = isRewinding ? [...actionHistory] : [...actionFuture]\r\n\r\n  // using `some` so it stops iterating when the threshold is reached\r\n  actions.some((action, idx) => {\r\n\r\n    // determine which lists we're moving to and from\r\n    const fromActions = isRewinding ? actionHistory : actionFuture\r\n    const toActions = isRewinding ? actionFuture : actionHistory\r\n\r\n    // undo or redo all of this action's mutations\r\n    action.mutations.forEach(mutation => {\r\n\r\n      // stop recording mutations so the setters don't overwrite the action history\r\n      internalState.recordMutations = false\r\n\r\n      // get a reference to the property in question\r\n      const { oldValue, newValue, path } = mutation\r\n      const parentPath = path.length > 1 ? path.slice(0, path.length - 1) : []\r\n      const lastKey = path[path.length - 1]\r\n      const ref = getValueFromPath(setters, parentPath)\r\n\r\n      // apply the mutation to the state\r\n      ref[lastKey] = isRewinding ? oldValue : newValue\r\n    })\r\n\r\n    // move the action from one list to the other\r\n    fromActions.shift()\r\n    toActions.unshift(action)\r\n\r\n    // stop iterating when the threshold is reached\r\n    return idx === finalIdx\r\n  })\r\n}\r\n","import getWatchers from './getWatchers'\r\nimport getGetters from './getGetters'\r\nimport getSetters from './getSetters'\r\nimport getDispatchers from './getDispatchers'\r\nimport connectToDevTools from './connectToDevTools'\r\n\r\nclass State {\r\n  constructor({\r\n    state = {},\r\n    computed = {},\r\n    actions = {},\r\n    name,\r\n  }) {\r\n    const stateRef = this\r\n\r\n    // establish an internal state for tracking things privately\r\n    const internalState = {\r\n      queue: [],\r\n      actionHistory: [],\r\n      actionFuture: [],\r\n      recordMutations: true,\r\n      userDefinedWatchers: new Map(),\r\n    }\r\n\r\n    // add getters to the state so they can be accessed externally\r\n    const getters = stateRef.getters = getGetters(state, computed)\r\n\r\n    // group \"add watcher\" methods corresponding to each property,\r\n    // so the end user can react to state changes\r\n    stateRef.watchers = getWatchers(getters, internalState)\r\n\r\n    // setters are not accessible externally, except via action methods\r\n    const setters = getSetters(state, computed, stateRef, internalState)\r\n\r\n    // add dispatchers for each action defined in the state config\r\n    stateRef.dispatchers = getDispatchers(name, actions, setters, internalState)\r\n\r\n    // connect to the browser dev tools extension\r\n    connectToDevTools(name, getters, setters, internalState)\r\n  }\r\n}\r\n\r\n// add a functional alternative for creating state\r\nState.createState = config => new State(config)\r\n\r\nexport default State\r\n","import { getValueFromPath, isObject } from \"./utilities\"\r\n\r\n/**\r\n * Get properties as \"add watcher\" methods so the end user can react to state changes\r\n * @param {object} getters - The immutable getters; attempting to set throws an error\r\n * @param {object} internalState - The state used to track various things privately\r\n * @param {Map} internalState.userDefinedWatchers - Map to track watchers with \"add watcher\" methods used as keys\r\n * @returns {object} - All the \"add watcher\" methods corresponding to every property on the state\r\n */\r\nexport default (getters, { userDefinedWatchers }) => {\r\n\r\n  // create a closure so we have access to the path in the reducer\r\n  const getReducer = (_path = []) => (watchers, key) => {\r\n    const path = [..._path, key]\r\n\r\n    // define the add watcher method\r\n    const addWatcher = callback => {\r\n      userDefinedWatchers.get(addWatcher).push(callback)\r\n    }\r\n    userDefinedWatchers.set(addWatcher, [])\r\n    watchers[key] = addWatcher\r\n\r\n    // if the getter value is an object, recursively add child properties\r\n    const value = getValueFromPath(getters, path)\r\n    if (isObject(value)) {\r\n      return Object.keys(value).reduce(getReducer(path), {})\r\n    }\r\n\r\n    // return the resulting object\r\n    return watchers\r\n  }\r\n\r\n  // kick off the reducer recursion\r\n  return Object.keys(getters).reduce(getReducer(), {})\r\n}\r\n","import State from '../lib/State.js'\r\n\r\nexport default State\r\nconst { createState } = State\r\nexport { State, createState }\r\n"],"names":["isObject","val","Object","prototype","toString","call","trimUndef","_arr","arr","i","length","pop","shift","getObjectChanged","oldValue","newValue","getDeepObjectDiff","oldObj","newObj","diff","oldIsObject","newIsObject","newObjKeys","keys","filter","key","getObjectDiff","deepDiff","forEach","push","getStateSetError","Error","getValueFromPath","obj","path","idx","value","isObj","isLastProp","TypeError","getPojo","initAccumulator","Array","isArray","reduce","pojo","DeepProxy","target","handler","basePath","ProxyUtility","needsNewProxy","proxy","getProxy","this","Proxy","get","set","defineProperty","_this","enumerable","state","computed","getters","computedGetters","stateRef","internalState","seal","runWatchers","watchers","userDefinedWatchers","prevComputed","acc","cKey","watcherPath","slice","watcherValue","destroyWatcher","_watchers","ref","findIndex","watcher","setTimeout","splice","addWatcher","cValue","cAddWatcher","_cWatchers","getRunWatchers","recordMutations","actionHistory","mutation","mutations","name","actions","setters","queue","dispatchers","payload","action","Promise","resolve","done","len","actionEntry","unshift","window","postMessage","type","message","stateName","addEventListener","data","dataIsValid","source","index","num","actionFuture","isRewinding","absNum","Math","abs","maxNum","finalIdx","some","fromActions","toActions","parentPath","lastKey","timeTravel","State","Map","getGetters","getReducer","_path","callback","getWatchers","getSetters","getDispatchers","connectToDevTools","createState","config"],"mappings":"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"}